<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="zh"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Spring4.0学习笔记@尚硅谷 之 JDBC部分(含事务管理) (3/n) - YaFey 的博客</title>
  <meta name="author" content="<a href='https://github.com/yafey'>YaFey</a>">
  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="OpooPressSiteRoot" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="Generator" content="OpooPress-1.1.1"/>
  <meta name="Generated" content="2015-09-23T01:40:09+08:00"/>
  <link rel="canonical" href="/article/2015/02/spring4.0-notes-shangguigu-jdbc-transaction/">
  
  
  <link href="/favicon.ico" rel="icon">
  <link href="/atom.xml" rel="alternate" title="YaFey 的博客" type="application/atom+xml">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic|PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link type="text/css" rel="stylesheet" href="/plugins/syntax-highlighter/styles/shCoreDefault.css"/>
  <!--[if lt IE 9]><script src="/javascripts/html5shiv.js"></script><![endif]-->
</head>
<body>
  <!--[if lt IE 9]><script src="/javascripts/unsupported-browser.js"></script><![endif]-->
  <header role="banner"><hgroup>
  <h1><a href="/">YaFey 的博客</a></h1>
    <h2>记录点点滴滴</h2>
</hgroup>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:http://yoursite.com" />
    <input class="search" type="text" name="q" results="0" placeholder="搜索"/>
  </fieldset>
</form>
<fieldset class="mobile-nav">
  <select onchange="if (this.value) { window.location.href = this.value;}">
    <option value="">导航&hellip;</option>
    <option value="/">&raquo; 文章</option>
    <option value="/archives/">&raquo; 归档</option>
    <option value="/category/">&raquo; 分类</option>
    <option value="/sample-page.html">&raquo; 示例页面</option>
    <option value="/about/">&raquo; 关于</option>
  </select>
</fieldset>

<ul class="main-navigation">
<li><a href="/">文章</a></li>
<li><a href="/archives/">归档</a></li>
<li><a href="/category/">分类</a></li>
<li><a href="/sample-page.html">示例页面</a></li>
<li><a href="/about/">关于</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
<div>
<article class="hentry" role="article">
  <header>
      <h1 class="entry-title">Spring4.0学习笔记@尚硅谷 之 JDBC部分(含事务管理) (3/n)</h1>

      <p class="meta">
		


<time datetime="2015-02-28T01:16:00+08:00" pubdate>2015年02月28日 01:16:00</time>
      </p>
  </header>

  <div class="entry-content"><p>112 - 148</p>
<blockquote><h1>目录</h1>
<ul>
<li><a href="#1.spring-support-jdbc">1. Spring 对 JDBC 的支持</a><ul>
<li><a href="#1.1.spring-jdbctemplate-desc">1.1. JdbcTemplate 简介</a></li>
<li><a href="#1.2.spring-jdbctemplate-use">1.2. 使用 JdbcTemplate </a><ul>
<li>简化 JDBC 模板查询</li>
<li>更新数据库 (<code>执行 INSERT , UPDATE , DELETE</code>)</li>
<li>查询数据库</li>
<li><a href="#spring-jdbctemplate-demo-code">JdbcTemplate 使用 示例</a></li>
<li><a href="#1.2.1.spring-jdbctemplate-usually-use">1.2.1. JdbcTemplate 开发中的常见写法 及 扩展 JdbcDaoSupport 示例代码 </a></li>
<li><a href="#1.2.2.spring-jdbctemplate-jmcs">1.2.2. 在 JDBC 模板中使用具名参数 : 可以为参数起名字</a><ul>
<li><a href="#pring-jdbctemplate-jmcs-demo-code">NamedParameterJdbcTemplate 中 使用 具名函数示例. (基于 JdbcTemplate 使用 示例)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1.3.spring-jdbctemplate-with-transaction">1.3.Spring  中的事务管理</a><ul>
<li>事务简介</li>
<li><a href="#1.3.1.spring-jdbctemplate-with-transaction-start-question">1.3.1.事务管理的问题(引出Spring处理事务的思路)</a></li>
<li><a href="#1.3.2.spring-jdbctemplate-with-transaction-use">1.3.2.Spring 中的事务管理 : 编程式事务管理 和 声明式事务管理(推荐)</a></li>
<li>Spring 中的事务管理器的不同实现</li>
<li><a href="#1.3.3.spring-jdbctemplate-with-transaction-use-annotation">1.3.3.用 @Transactional 注解声明式地管理事务</a></li>
<li><a href="#1.3.4.spring-jdbctemplate-with-transaction-broadcast">1.3.4.事务传播属性</a></li>
<li><a href="#1.3.5.spring-jdbctemplate-with-transaction-bingfa">1.3.5.并发事务所导致的问题</a></li>
<li><a href="#1.3.6.spring-jdbctemplate-with-transaction-xml">1.3.6. xml方式配置事务</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1><span id="1.spring-support-jdbc">1. Spring 对 JDBC 的支持</span></h1>
<h2><span id="1.1.spring-jdbctemplate-desc">1.1. JdbcTemplate 简介</span></h2>
<ul>
<li>为了使 JDBC 更加易于使用, Spring 在 JDBC API 上定义了一个抽象层, 以此建立一个 JDBC 存取框架.</li>
<li>作为 <strong>Spring JDBC 框架的核心</strong>, <strong>JDBC 模板</strong>的设计目的是为不同类型的 JDBC 操作提供<strong>模板方法</strong>. 每个模板方法都能控制整个过程, 并允许覆盖过程中的特定任务. 通过这种方式, 可以在尽可能保留灵活性的情况下, 将数据库存取的工作量降到最低.</li>
</ul>
<h2><span id="1.2.spring-jdbctemplate-use">1.2. 使用 JdbcTemplate </span></h2>
<h3>简化 JDBC 模板查询</h3>
<ul>
<li>每次使用都创建一个 JdbcTemplate 的新实例, 这种做法效率很低下.</li>
<li><strong>JdbcTemplate 类被设计成为线程安全的</strong>, 所以可以再 IOC 容器中声明它的单个实例, 并将这个实例注入到所有的 DAO 实例中.</li>
<li>JdbcTemplate 也利用了 Java 1.5 的特定(自动装箱, 泛型, 可变长度等)来简化开发</li>
<li>Spring JDBC 框架还提供了一个 JdbcDaoSupport 类来简化 DAO 实现. 该类声明了 jdbcTemplate 属性, 它可以从 IOC 容器中注入, 或者自动从数据源中创建.</li>
</ul>
<h3>更新数据库 (<code>执行 INSERT , UPDATE , DELETE</code>)</h3>
<ul>
<li>用 sql 语句和参数更新数据库: <strong>update</strong><pre class='brush:java'>public int update(String sql,
              Object... args)
       throws DataAccessException
</pre></li>
<li>批量更新数据库: <strong>batchUpdate</strong> : <strong>执行批量更新 : 批量的 INSERT , UPDATE ,DELETE</strong> <br />
<strong>最后一个参数是 List<Object[]> 类型</strong> :<br />
因为修改一条记录需要一个 Object[] 类型, 那么多条就需要多个 Object[] .<pre class='brush:java'>public int[] batchUpdate(String sql,
                     List&lt;Object[]&gt; batchArgs)
</pre></li>
</ul>
<h3>查询数据库</h3>
<ul>
<li>查询单行: <strong>queryForObject</strong> : 从数据库中获取一条记录, 实际得到对应的一个对象. <br /><ul>
<li>注意<em>不是调用 <code>queryForObject(String sql,Class&lt;Employee&gt; requiredType, Object... args)</code> 方法!</em> <br />
<strong>而需要调用 <code>queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args)</code></strong></li>
<li>其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper. <br /></li>
<li>使用 SQL中列的别名完成列名和类的属性名的映射. 例如 last_name lastName. <br /></li>
<li><strong>不支持级联属性(不能根据外键查出关联的对象).</strong> JdbcTemplate 到底是一个JDBC 的小工具, 而不是 ORM 框架.<pre class='brush:java'>public &lt;T&gt; T queryForObject(String sql,
                    RowMapper&lt;T&gt; rowMapper,
                    Object... args)
         throws DataAccessException
</pre></li>
</ul>
</li>
<li>便利的 BeanPropertyRowMapper 实现 :
<img src="/blog_images/program/spring4.0/JDBC/1.beanPropertyRowMapper.png" alt="便利的 BeanPropertyRowMapper 实现" title="便利的 BeanPropertyRowMapper 实现" /></li>
<li>查询多行: <strong>query</strong><pre class='brush:java'>public &lt;T&gt; List&lt;T&gt; query(String sql,
                     RowMapper&lt;T&gt; rowMapper,
                     Object... args)
          throws DataAccessException
</pre></li>
<li>单值查询: <strong>queryForObject</strong><pre class='brush:java'>public &lt;T&gt; T queryForObject(String sql,
                        Class&lt;T&gt; requiredType,
                        Object... args)
             throws DataAccessException
</pre></li>
</ul>
<h3><span id="1.2.1.spring-jdbctemplate-usually-use">1.2.1. JdbcTemplate 开发中的常见写法 及 扩展 JdbcDaoSupport 示例代码 </span></h3>
<ul>
<li><strong>JdbcTemplate 开发中的常见写法</strong> (推荐的写法)<pre class='brush:java'>@Repository
public class EmployeeDao {
@Autowired
private JdbcTemplate jdbcTemplate;

public Employee get(Integer id) {
    String sql = "SELECT id, last_name lastName, email, dept_id as \"department.id\" FROM employee WHERE id = ?";
    RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(
            Employee.class);
    Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1);
    return employee;
}
}
</pre></li>
<li>扩展 JdbcDaoSupport 示例代码 (不推荐使用,比较麻烦)<pre class='brush:java'>@Deprecated // 不推荐使用这样的方式 (继承 JdbcDaoSupport ) , 麻烦. 而推荐直接使用 JdbcTemplate 作为 Dao 类的成员变量 (见 EmployeeDao 示例).
@Repository
public class DepartmentDao extends JdbcDaoSupport {
/**必须要设置一个 DataSource .
 * 因为 setDataSource() 方法是 final 的, 不能被重写.
 * 所以只能在 配置文件中搞,  或者   自定义一个方法, 在方法中调用 setDataSource() 方法.
 */
@Autowired
public void setDataSource2(DataSource dataSource){
    setDataSource(dataSource);  // 调用 JdbcDaoSupport 类中的 setDataSource() 方法.
}
public Department get(Integer id){
    String sql = "SELECT id,name FROM department WHERE id=?";
    RowMapper&lt;Department&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Department.class);
    return getJdbcTemplate().queryForObject(sql, rowMapper, id);
}
}
</pre></li>
</ul>
<h3><span id="1.2.2.spring-jdbctemplate-jmcs">1.2.2. 在 JDBC 模板中使用具名参数 : 可以为参数起名字</span></h3>
<ul>
<li>在经典的 JDBC 用法中, SQL 参数是用<code>占位符 ?</code> 表示,并且受到位置的限制. 定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定.</li>
<li>在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用<strong>具名参数(named parameter)</strong>.</li>
<li><strong>具名参数</strong>: <strong>SQL 按名称(以冒号开头)而不是按位置进行指定.</strong> 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代 .</li>
<li><strong>具名参数只在 <code>NamedParameterJdbcTemplate</code> 中得到支持 </strong>.<ul>
<li>在 SQL 语句中使用<strong>具名参数</strong>时, 可以<strong>在一个 Map 中提供参数值, 参数名为键</strong></li>
<li>也可以使用 <strong>SqlParameterSource 参数</strong>.</li>
<li>批量更新时可以提供 <strong>Map 或 SqlParameterSource 的数组</strong>.</li>
</ul>
</li>
</ul>
<pre class='brush:java'>/*
 * 在 JDBC 模板中使用具名参数 的方法举例
 */
// update 1
public int update(String sql,
                  Map&lt;String,?&gt; paramMap)
           throws DataAccessException
// update 2  -- 更便捷的使用.
public int update(String sql,
                  SqlParameterSource paramSource)
           throws DataAccessException
// batchUpdate 1
public int[] batchUpdate(String sql,
                         Map&lt;String,?&gt;[] batchValues)
// batchUpdate 2
public int[] batchUpdate(String sql,
                         SqlParameterSource[] batchArgs)
</pre><blockquote><h3><span id="spring-jdbctemplate-jmcs-demo-code">NamedParameterJdbcTemplate 中 使用 具名函数示例. (基于 JdbcTemplate 使用 示例)</span></h3>
<p>xml 配置文件</p>
<pre class='brush:xml'>&lt;!-- 配置 NamedParameterJdbcTemplate , 该对象可以使用具名参数,其没有无参数的构造器,所以必须为其构造器指定参数.--&gt;
&lt;bean id="namedParameterJdbcTemplate"
class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt;
    &lt;!-- namedParameterJdbcTemplate 是一个带参的构造器, 需要传入一个 dataSource --&gt;
    &lt;constructor-arg ref="dataSource"/&gt;
&lt;/bean&gt;
</pre><p>使用 具名函数 的两个示例.</p>
<pre class='brush:java'>/**
 * 在 JDBC 模板中使用 具名参数 : 可以为参数起名字.
 * 1. 好处 : 若有多个参数 , 则不用再去对应位置, 直接对应参数名, 便于维护.
 * 2. 缺点 : 较为麻烦.
 */
@Test
public void testNamedParameterJdbcTemplate(){
    String sql = "INSERT INTO employee(last_name,email,dept_id) VALUES(:ln,:email,:deptid)";
//      NamedParameterJdbcTemplate namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class);
    Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;();
    paramMap.put("ln", "namedParameterJdbcTemplate");
    paramMap.put("email", "namedParameter@JdbcTemplate.com");
    paramMap.put("deptid", "2");
    namedParameterJdbcTemplate.update(sql, paramMap);
}
/**
 * 在 JDBC 模板中使用 具名参数 更便捷的写法. 使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作.
 * 1. SQL 语句中的参数名和类的属性一致!
 * 2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数.
 */
@Test
public void testNamedParameterJdbcTemplate2(){
    String sql = "INSERT INTO employee(last_name,email,dept_id) VALUES(:lastName,:email,:deptId)";
//      NamedParameterJdbcTemplate namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class);
    Employee emp = new Employee();
    emp.setLastName("NPJT");
    emp.setEmail("namedPara@jdbcTemp.com");
    emp.setDeptId(1);
    SqlParameterSource paramSource = new BeanPropertySqlParameterSource(emp);
    namedParameterJdbcTemplate.update(sql, paramSource);
}
</pre></blockquote>
<p>&nbsp;</p>
<blockquote><h3><span id="spring-jdbctemplate-demo-code">JdbcTemplate 使用 示例</span></h3>
<p>data.sql 准备测试数据</p>
<pre class='brush:sql'>create table employee(
    id bigint primary key auto_increment,
    last_name varchar(50),
    email varchar(50),
    dept_id int
);
create table department(
    id bigint primary key auto_increment,
    name varchar(50)
);
-- 插入 employee 的测试数据
INSERT INTO employee(last_name,email,dept_id) values("AA", "aa@aa.com", 1);
INSERT INTO employee(last_name,email,dept_id) values("BB", "bb@bb.com", 3);
INSERT INTO employee(last_name,email,dept_id) values("CC", "cc@cc.com", 2);
INSERT INTO employee(last_name,email,dept_id) values("DD", "dd@dd.com", 1);
-- 插入 department 的测试数据
insert into department(name) values('test');
insert into department(name) values('dev');
insert into department(name) values('deploy');
insert into department(name) values('create');
</pre><p>db.properties  配置 数据库连接源</p>
<pre class='brush:sql'>jdbc.user=root
jdbc.password=root
jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.jdbcUrl=jdbc:mysql:///test
jdbc.initialPoolSize=5
jdbc.maxPoolSize=10
</pre><p>applicationContext.xml 配置文件 , 因为 OpooPress 的原因, 下面的 <code>￥</code> 为 <code>$</code>.<br /></p>
<pre class='brush:xml'>&lt;!-- 导入外部文件 --&gt;
&lt;context:property-placeholder location="classpath:db.properties"/&gt;
&lt;!-- 配置 c3p0 数据域 --&gt;
&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
    &lt;property name="user" value="￥{jdbc.user}"&gt;&lt;/property&gt;
    &lt;property name="password" value="￥{jdbc.password}"&gt;&lt;/property&gt;
    &lt;property name="driverClass" value="￥{jdbc.driverClass}"&gt;&lt;/property&gt;
    &lt;property name="jdbcUrl" value="￥{jdbc.jdbcUrl}"&gt;&lt;/property&gt;
    &lt;property name="initialPoolSize" value="￥{jdbc.initialPoolSize}"&gt;&lt;/property&gt;
    &lt;property name="maxPoolSize" value="￥{jdbc.maxPoolSize}"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置 Spring 的 JDBCTemplate --&gt;
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;!-- jdbcTemplate 中需要有一个最基本的属性 dataSource --&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 自动扫描 --&gt;
&lt;context:component-scan base-package="com.yafey.spring.jdbc"&gt;&lt;/context:component-scan&gt;
</pre><p>TestJDBC.java , 测试类 , 使用 JUnit 测试 (在方法名上右键 run as &ndash;> junit).</p>
<pre class='brush:java'>package com.yafey.spring.jdbc;
public class TestJDBC {
    private ApplicationContext ctx = null;
    private JdbcTemplate jdbcTemplate;
    // 成员代码块. 
    {
        ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate");
    }
    /**
     * 测试数据源是否能正常连接.
     * 
     * @throws SQLException
     */
    @Test
    public void testDataSourceConnection() throws SQLException {
        DataSource dataSource = ctx.getBean(DataSource.class);
        System.out.println(dataSource.getConnection());
    }
    /**
     * 执行 INSERT , UPDATE , DELETE
     * 
     * @throws SQLException
     */
    @Test
    public void testUpdate() throws SQLException {
        String sql = "UPDATE employee SET last_name = ? WHERE id = ?";
        jdbcTemplate.update(sql, "Jack", 4);
    }
    /**
     * 执行批量更新 : 批量的 INSERT , UPDATE , DELETE 最后一个参数是 List&lt;Object[]&gt; 类型 :
     * 因为修改一条记录需要一个 Object[] 类型, 那么多条就需要多个 Object[] .
     * 
     * @throws SQLException
     */
    @Test
    public void testBatchUpdate() throws SQLException {
        String sql = "INSERT INTO employee(last_name,email,dept_id) values(?,?,?)";
        List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        batchArgs.add(new Object[] { "AA", "aa@aa.com", 1 });
        batchArgs.add(new Object[] { "BB", "bb@bb.com", 3 });
        batchArgs.add(new Object[] { "CC", "cc@cc.com", 2 });
        batchArgs.add(new Object[] { "DD", "dd@dd.com", 1 });
        jdbcTemplate.batchUpdate(sql, batchArgs);
    }
    /**
     * 从数据库中获取一条记录, 实际得到对应的一个对象.
     * 注意不是调用 queryForObject(String sql,Class&lt;Employee&gt; requiredType, Object... args) 方法! 
     * 而需要调用   queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args)
     * 1. 其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper. &lt;br/&gt; 
     * 2. 使用 SQL中列的别名完成列名和类的属性名的映射. 例如 last_name lastName. &lt;br/&gt;
     * 3. 不支持级联属性(不能根据外键查出关联的对象). JdbcTemplate 到底是一个JDBC 的小工具, 而不是 ORM 框架.
     */
    @Test
    public void testQueryForObject() {
        String sql = "SELECT id, last_name lastName, email, dept_id as \"department.id\" FROM employee WHERE id = ?";
        RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(
                Employee.class);
        Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1);
        System.out.println(employee);
    }
    /**
     * 查到实体类的集合
     * 注意调用的不是 queryForList 方法
     */
    @Test
    public void testQueryForList(){
        String sql = "SELECT id, last_name lastName, email FROM employee WHERE id &gt; ?";
        RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class);
        List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper,1);
        System.out.println(employees);
    }
    /**
     * 获取单个列的值, 或做统计查询
     * 使用 queryForObject(String sql, Class&lt;Long&gt; requiredType) 
     */
    @Test
    public void testQueryForObject2(){
        String sql = "SELECT count(3) FROM employee";
        long count = jdbcTemplate.queryForObject(sql, Long.class);
        System.out.println(count);
    }
}
</pre></blockquote>
<h2><span id="1.3.spring-jdbctemplate-with-transaction">1.3.Spring  中的事务管理</span></h2>
<h3>事务简介</h3>
<ul>
<li>事务管理是企业级应用程序开发中必不可少的技术,  <strong>用来确保数据的完整性和一致性.</strong></li>
<li>事务就是<strong>一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用</strong></li>
<li>事务的<strong>四个关键属性(ACID)</strong><ul>
<li><strong>原子性(atomicity)</strong>: 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用.</li>
<li><strong>一致性(consistency)</strong>: 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中.</li>
<li><strong>隔离性(isolation)</strong>: 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏.</li>
<li><strong>持久性(durability)</strong>: 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中.</li>
</ul>
</li>
</ul>
<h3><span id="1.3.1.spring-jdbctemplate-with-transaction-start-question">1.3.1.事务管理的问题(引出Spring处理事务的思路)</span></h3>
<blockquote><h4>在 JDBC 中使用 事务</h4>
<p><img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-in-jdbc.png" alt="在 JDBC 中使用 事务" title="在 JDBC 中使用 事务" /></p>
<ul>
<li>问题:<ul>
<li>必须<strong>为不同的业务方法重写</strong>类似的样板代码</li>
<li>这段代码是特定于 JDBC 的, 一旦选择类其它数据库存取技术, 代码需要作出相应的修改 .</li>
</ul>
</li>
<li><strong>解决 方案 (按 AOP 的思路 )</strong>: 使用 Spring处理事务的基本原理<ul>
<li><strong>获取连接 和 开启事务</strong> &mdash;相当于&mdash;> <strong>前置通知 @Before</strong></li>
<li><strong>提交事务</strong> &mdash;相当于&mdash;> <strong>返回通知 @Returning</strong></li>
<li><strong>回滚事务</strong> &mdash;相当于&mdash;> <strong>异常通知</strong></li>
<li><strong>关闭连接</strong> &mdash;相当于&mdash;> <strong>后置通知</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h3><span id="1.3.2.spring-jdbctemplate-with-transaction-use">1.3.2.Spring 中的事务管理 : 编程式事务管理 和 声明式事务管理(推荐)</span></h3>
<ul>
<li>作为企业级应用程序框架, <strong>Spring 在不同的事务管理 API 之上定义了一个抽象层.</strong> 而应用程序开发人员不必了解底层的事务管理 API<em>(处理 JDBC / Hibernate 等共用一套事务机制. )</em>, 就可以使用 Spring 的事务管理机制. <strong>有了这些事务机制, 事务管理代码就能独立于特定的事务技术了.</strong></li>
<li>Spring 既支持编程式事务管理, 也支持声明式的事务管理.</li>
<li><strong>编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚.</strong> 在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码.</li>
<li><strong><code>声明式事务管理</code>:</strong> 大多数情况下比编程式事务管理更好用. 它<strong>将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理.</strong> 事务管理作为一种横切关注点, 可以通过 AOP 方法模块化. <strong>Spring 通过 Spring AOP 框架支持声明式事务管理.</strong></li>
</ul>
<h3>Spring 中的事务管理器的不同实现</h3>
<p>Spring 的核心事务管理抽象是 <code>org.springframework.transaction Interface PlatformTransactionManager</code> .
它为事务管理封装了一组独立于技术的方法. 无论使用 Spring 的哪种事务管理策略(编程式或声明式), 事务管理器都是必须的.</p>
<ul>
<li><strong>对于 JDBC</strong> : 在应用程序中<strong>只需要处理一个数据源</strong>(dataSource), 而且通过 JDBC 存取<pre class='brush:java'>org.springframework.jdbc.datasource
Class DataSourceTransactionManager
</pre></li>
<li><strong>对于 Hibernate</strong>：用 Hibernate 框架存取数据库<pre class='brush:java'>org.springframework.orm.hibernate3 
Class HibernateTransactionManager
</pre></li>
<li><strong>对于 JTA</strong>: 在 JavaEE 应用服务器上用 JTA(Java Transaction API) 进行事务管理<pre class='brush:java'>org.springframework.transaction.jta 
Class JtaTransactionManager
</pre></li>
<li><em>…… 其他的方式</em></li>
<li><strong>事务管理器</strong>以<strong>普通的 Bean </strong>形式声明在 Spring IOC 容器中</li>
</ul>
<h3><span id="1.3.3.spring-jdbctemplate-with-transaction-use-annotation">1.3.3.用 @Transactional 注解声明式地管理事务</span></h3>
<ul>
<li>除了在带有切入点, 通知和增强器的 Bean 配置文件中声明事务外, Spring 还允许<strong>简单地用 <code>@Transactional 注解</code>来标注事务方法</strong>.</li>
<li><strong>为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解.</strong> 根据 Spring AOP 基于代理机制, <strong>只能标注公有方法</strong>.</li>
<li>可以在<strong>方法</strong>或者<strong>类级别上</strong>添加 <code>@Transactional 注解</code>. 当把这个注解应用到类上时, 这个类中的所有公共方法都会被定义成支持事务处理的.</li>
<li>在 Bean 配置文件中只需要启用 <code>&lt;tx:annotation-driven&gt; 元素</code>, 并为之指定事务管理器就可以了.</li>
<li>如果事务处理器的名称是 <code>transactionManager</code>, 就可以在<code>&lt;tx:annotation-driven&gt; 元素</code>中省略 transaction-manager 属性. 这个元素会自动检测该名称的事务处理器.</li>
</ul>
<blockquote><h3>spring 中事务的使用 示例</h3>
<p><img src="/blog_images/program/spring4.0/JDBC/1.3.1.transaction-in-spring-demo-uml.png" alt="在 JDBC 中使用 事务 示例 的 UML图" title="在 JDBC 中使用 事务 示例 的 UML图" />
xml 配置文件中 配置.</p>
<pre class='brush:xml'>&lt;!-- 配置事务管理器 --&gt;
&lt;bean id="transactionManager" 
class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;/bean&gt;
&lt;!-- 启用事务注解 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;
&lt;!-- 自动扫描 --&gt;
&lt;context:component-scan base-package="com.yafey.spring"&gt;&lt;/context:component-scan&gt;
</pre><p>在对应的方法添加 事务注解</p>
<pre class='brush:java'>@Transactional  // 添加事务注解
@Override
public void purchase(String username, String isbn) {
    // 1, 获取书的单价
    int price = bookShopDao.findBookPriceByIsbn(isbn);
    // 2, 更新书的库存
    bookShopDao.updateBookStock(isbn);
    // 3, 更新用户余额
    bookShopDao.updateUserAccount(username, price);
}
</pre></blockquote>
<h3><span id="1.3.4.spring-jdbctemplate-with-transaction-broadcast">1.3.4.事务传播属性</span></h3>
<ul>
<li>当<strong>事务方法</strong>被<strong>另一个事务方法调用</strong>时, <strong>必须指定事务应该如何传播</strong>. 例如: 方法可能 <em>继续在现有事务中运行</em>, 也可能 <em>开启一个新事务, 并在自己的事务中运行</em>.</li>
<li>事务的传播行为可以由传播属性指定. <strong>Spring 定义了 7  种类传播行为</strong>.
<img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-broadcast-supported-in-spring.png" alt="Spring 定义的 7  种类传播行为" title="Spring 定义的 7  种类传播行为" /></li>
</ul>
<blockquote><h3>事务传播属性 <code>Required</code>(有一个不成功都不成功) 和 <code>REQUIRES_NEW</code>(保证其中能成功的) 示例</h3>
<blockquote><h4>需求</h4>
<ul>
<li>新定义 Cashier 接口: 表示客户的结账操作</li>
<li>修改数据表信息如下, 目的是用户 Tom 在结账时, <strong>余额只能支付第一本书, 不够支付第二本书</strong>：
<img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-in-spring-broadcast.jpg" alt="事务传播属性示例UML图" title="事务传播属性示例UML图" /></li>
</ul>
</blockquote>
<h4>REQUIRED 传播行为</h4>
<ul>
<li>当 bookService 的 purchase() 方法被另一个事务方法 checkout() 调用时, 它默认会在现有的事务内运行. 这个<strong>默认的传播行为就是 <code>REQUIRED</code></strong>. 因此在 checkout() 方法的开始和终止边界内只有一个事务. <strong>这个事务只在 checkout() 方法结束的时候被提交</strong>, 结果用户一本书都买不了</li>
<li>事务传播属性可以在 <code>@Transactional 注解</code>的 <code>propagation 属性</code>中定义
<img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-broadcast-required.jpg" alt="REQUIRED 传播行为 过程说明" title="REQUIRED 传播行为  过程说明" /></li>
</ul>
<h4>REQUIRES_NEW 传播行为</h4>
<ul>
<li><strong>另一种常见的传播行为是 <code>REQUIRES_NEW</code></strong>. 它表示该方法<strong>必须启动一个新事务</strong>, 并在自己的事务内运行. 如果<strong>有事务在运行</strong>, 就应该先<strong>挂起它</strong>.
<img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-broadcast-requires_new.jpg" alt="REQUIRES_NEW 传播行为 过程说明" title="REQUIRES_NEW 传播行为  过程说明" /></li>
</ul>
<blockquote><h3>事务传播属性 示例 代码.</h3>
<p>BookShopCashier.java , 购买多本书.</p>
<pre class='brush:java'>@Service
public class BookShopCashier implements Cashier {
    @Autowired
    private BookShopService bookShopService;
    @Transactional
    public void checkout(List&lt;String&gt; isbns,String username) {
        for (String isbn : isbns) {
            bookShopService.purchase(username, isbn);
        }
    }
    // setter ... getter...
}
</pre><p>BookShopServiceImpl.java , 被另一个事务调用的 购买一本书的事务.</p>
<pre class='brush:java'>@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {
    @Autowired
    private BookShopDao bookShopDao;
    // 使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时, 如何使用事务.
    // 默认取值为 REQUIRED , 即使用 调用方法的事务.  // 账户余额130只能购买一本书(80,60)时, 两本都购买不成功.
    // REQUIRES_NEW : 使用自己的事务, 调用的方法的事务 被挂起.  // 账户余额130只能购买一本书(80,60)时, 第一本购买成功.
    @Transactional(propagation=Propagation.REQUIRES_NEW)  // 添加事务注解
    @Override
    public void purchase(String username, String isbn) {
        // 1, 获取书的单价
        int price = bookShopDao.findBookPriceByIsbn(isbn);
        // 2, 更新书的库存
        bookShopDao.updateBookStock(isbn);
        // 3, 更新用户余额
        bookShopDao.updateUserAccount(username, price);
    }
}
</pre></blockquote>
</blockquote>
<h3><span id="1.3.5.spring-jdbctemplate-with-transaction-bingfa">1.3.5.并发事务所导致的问题(事务的隔离级别)</span></h3>
<h4>并发事务所导致的问题</h4>
<ul>
<li>当同一个应用程序或者不同应用程序中的<strong>多个事务在同一个数据集上并发执行</strong>时, 可能会出现许多意外的问题</li>
<li><strong>并发事务所导致的问题</strong>可以分为<strong>下面三种类型</strong>:<ul>
<li><strong><code>脏读</code></strong>: 对于两个事物 T1, T2, <strong>T1 读取了已经被 T2 更新但 还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的</strong>.</li>
<li><strong><code>不可重复读</code></strong>:对于两个事物 T1, T2, <strong>T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了</strong>.</li>
<li><strong><code>幻读</code></strong>:对于两个事物 T1, T2, <strong>T1  从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行</strong>.</li>
</ul>
</li>
</ul>
<h4>事务的隔离级别</h4>
<ul>
<li>从理论上来说, 事务应该彼此<strong>完全隔离</strong>, 以避免并发事务所导致的问题. 然而, 那样会对<strong>性能产生极大的影响</strong>, 因为事务必须按顺序运行.</li>
<li>在<strong>实际开发中</strong>, 为了提升性能, 事务会<strong>以较低的隔离级别运行</strong>.</li>
<li>事务的隔离级别可以<strong>通过隔离事务属性指定</strong></li>
<li><strong>Spring 支持的事务隔离级别</strong> : 5 种.<ul>
<li>事务的隔离级别要得到<strong>底层数据库引擎的支持</strong>, 而不是应用程序或者框架的支持.</li>
<li><strong>Oracle 支持</strong>的 2 种事务隔离级别：<code>READ_COMMITED</code> , <code>SERIALIZABLE</code></li>
<li><strong>Mysql 支持</strong> 4 中事务隔离级别.
<img src="/blog_images/program/spring4.0/JDBC/1.3.transaction-seprate-level-in-spring.png" alt="Spring 中支持的 5 种 事务隔离级别" title="Spring 中支持的 5 种 事务隔离级别" /></li>
</ul>
</li>
</ul>
<h4>2.设置隔离事务属性  (1 为上面的 事务传播属性)</h4>
<ul>
<li>用 <code>@Transactional 注解</code>声明式地管理事务时可以在 <code>@Transactional</code> 的 <strong><code>isolation 属性</code></strong>中设置隔离级别.</li>
</ul>
<blockquote><p>示例:</p>
<ul>
<li>注解方式<pre class='brush:java'>// 使用 isolution 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED
@Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.READ_COMMITTED)
@Override
public void purchase(String username, String isbn) {
// ... 购买一本书的方法... 
}
</pre></li>
</ul>
</blockquote>
<h4>3.设置回滚事务属性</h4>
<ul>
<li><strong>默认情况下只有未检查异常</strong>(RuntimeException和Error类型的异常)<strong>会导致事务回滚</strong>. 而受检查异常不会.
事务的回滚规则可以通过 <code>@Transactional 注解</code>的 <strong><code>rollbackFor</code></strong> 和 <strong><code>noRollbackFor</code></strong> 属性来定义. 这两个属性被声明为 Class[] 类型的, 因此可以为这两个属性指定多个异常类.<ul>
<li><strong><code>rollbackFor</code></strong>:  遇到时必须<strong>进行回滚</strong></li>
<li><strong><code>noRollbackFor</code></strong>: 一组异常类，遇到时<strong>必须不回滚</strong></li>
</ul>
</li>
</ul>
<blockquote><p>示例:</p>
<ul>
<li>注解方式<pre class='brush:java'>// 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过 noRollbackFor/rollbackFor 属性进行设置. 通常情况下默认值即可. 
@Transactional(propagation=Propagation.REQUIRED, noRollbackFor={UserAccoutException.class})
@Override
public void purchase(String username, String isbn) {
// ... 购买一本书的方法... 
}
</pre></li>
</ul>
</blockquote>
<h4>4. 设置只读属性</h4>
<ul>
<li>只读属性可以在 <code>@Transactional 注解</code>中 <strong><code>readOnly 属性</code></strong> 来定义.超时属性<strong>以秒为单位</strong>来计算.</li>
<li>表示这个<strong>事务只读取数据但不更新数据</strong>, 这样可以帮助数据库引擎优化事务. 若真的是一个只读取数据库值的方法, 应设置<code>readOnly=true</code></li>
</ul>
<blockquote><p>示例:</p>
<ul>
<li>注解方式<pre class='brush:java'>// 4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务. 若真的是一个只读取数据库值的方法, 应设置 readOnly=true
@Transactional(propagation=Propagation.REQUIRED,
            readOnly=false)
@Override
public void purchase(String username, String isbn) {
// ... 购买一本书的方法... 
}
</pre></li>
</ul>
</blockquote>
<h4>5. 设置超时属性</h4>
<ul>
<li>超时属性可以在 <code>@Transactional 注解</code>中 <strong><code>timeout 属性</code></strong> 来定义.超时属性<strong>以秒为单位</strong>来计算.</li>
<li>表示<strong>指定强制回滚之前事务可以占用的时间</strong>.</li>
</ul>
<blockquote><p>示例:</p>
<ul>
<li>注解方式<pre class='brush:java'>// 5.使用 timeout 指定强制回滚之前事务可以占用的时间 , 单位为 秒. 
@Transactional(propagation=Propagation.REQUIRED,
            timeout = 3)
@Override
public void purchase(String username, String isbn) {
// ... 购买一本书的方法... 
}
</pre></li>
</ul>
</blockquote>
<h2><span id="1.3.6.spring-jdbctemplate-with-transaction-xml">1.3.6. xml方式配置事务</span></h2>
<p>applicationContext.xml 配置文件 , 因为 OpooPress 的原因, 下面的 <code>￥</code> 为 <code>$</code>.<br /></p>
<pre class='brush:xml'>&lt;!-- 导入外部文件 --&gt;
&lt;context:property-placeholder location="classpath:db.properties"/&gt;
&lt;!-- 配置 c3p0 数据域 --&gt;
&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
    &lt;property name="user" value="￥{jdbc.user}"&gt;&lt;/property&gt;
    &lt;property name="password" value="￥{jdbc.password}"&gt;&lt;/property&gt;
    &lt;property name="driverClass" value="￥{jdbc.driverClass}"&gt;&lt;/property&gt;
    &lt;property name="jdbcUrl" value="￥{jdbc.jdbcUrl}"&gt;&lt;/property&gt;
    &lt;property name="initialPoolSize" value="￥{jdbc.initialPoolSize}"&gt;&lt;/property&gt;
    &lt;property name="maxPoolSize" value="￥{jdbc.maxPoolSize}"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置 Spring 的 JDBCTemplate--&gt;
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;!-- jdbcTemplate 中需要有一个最基本的属性 dataSource --&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置 bean --&gt;
&lt;bean id="bookShopDao_xml" class="com.yafey.xml.spring.tx_xml.BookShopDaoImpl"&gt;
    &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="bookShopService_xml" class="com.yafey.xml.spring.tx_xml.service.BookShopServiceImpl"&gt;
    &lt;property name="bookShopDao" ref="bookShopDao_xml"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="cashier_xml" class="com.yafey.xml.spring.tx_xml.service.BookShopCashier"&gt;
    &lt;property name="bookShopService" ref="bookShopService_xml"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 1. 配置事务管理器 --&gt; &lt;!-- 声明事务管理器 --&gt;
&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 2. 配置事务属性 --&gt;  &lt;!-- 声明事务通知 --&gt;
&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 根据方法名指定事务的属性 --&gt;
        &lt;tx:method name="purchase" propagation="REQUIRED"/&gt;
        &lt;tx:method name="get*" read-only="true"/&gt;
        &lt;tx:method name="find*" read-only="true"/&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
&lt;!-- 3. 配置事务切入点, 以及把事务切入点和事务属性关联起来 --&gt;  &lt;!-- 声明 事务通知需要通知方法(即需要进行事务管理的方法) --&gt;
&lt;aop:config&gt;  
    &lt;aop:pointcut expression="execution(* com.yafey.spring.tx_xml.*.*(..))" 
        id="txPointCut"/&gt;   &lt;!-- 切点放在 需要事务管理的 类 之上的包 (事务的传播性,有多个方法需要进行事务管理) --&gt; 
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/&gt;  
&lt;/aop:config&gt;
</pre></div>
  <footer>
    <p class="meta">
<span class="byline author vcard">作者 <span class="fn"><a href='https://github.com/yafey'>YaFey</a></span></span>      


<time datetime="2015-02-28T01:16:00+08:00" pubdate>2015年02月28日 01:16:00</time>

<span class="categories">属于 <a class="category" href="/category/tech/java/">Java</a>, <a class="category" href="/category/tech/java/framework/">Java框架</a>, <a class="category" href="/category/tech/java/framework/spring/">Java框架-Spring</a>
 分类</span>


<span class="categories">被贴了 <a class="tag" href="/tag/spring/">Spring</a>, <a class="tag" href="/tag/shang-gui-gu/">尚硅谷</a>
 标签</span>
    </p>
<div class="sharing">
  </div>
<p>
  <h2>相关文章</h2>
  <ul id="related-posts-list">
      <li class="post">
        <a href="/article/2015/02/spring4.0-notes-shangguigu-aop/">Spring4.0学习笔记@尚硅谷 之 AOP部分 (2/n)</a>
        <div class="source right"><time datetime="2015-02-25T00:39:00">2015-02-25</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/02/spring4.0-notes-shangguigu-IOC/">Spring4.0学习笔记@尚硅谷 之 IOC部分 (1/n)</a>
        <div class="source right"><time datetime="2015-02-07T00:06:00">2015-02-07</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/spring-feature-group/">Spring4.0学习笔记--特性部分(1/n)</a>
        <div class="source right"><time datetime="2015-03-11T10:49:00">2015-03-11</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/struts2-notes-shangguigu/">Struts2学习笔记@尚硅谷</a>
        <div class="source right"><time datetime="2015-03-05T22:58:00">2015-03-05</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/javaweb-servlet-notes-shangguigu/">JavaWeb学习笔记@尚硅谷---JavaWeb-Servlet(1/n)</a>
        <div class="source right"><time datetime="2015-03-07T13:54:00">2015-03-07</time></div>
      </li>
  </ul>
</p>    <p class="meta">
        <a class="basic-alignment left" href="/article/2015/02/spring4.0-notes-shangguigu-aop/" title="上一篇: Spring4.0学习笔记@尚硅谷 之 AOP部分 (2/n)">&laquo; Spring4.0学习笔记@尚硅谷 之 AOP部分 (2/n)</a>
        <a class="basic-alignment right" href="/article/2015/03/struts2-notes-shangguigu/" title="下一篇: Struts2学习笔记@尚硅谷">Struts2学习笔记@尚硅谷 &raquo;</a>
    </p>
  </footer>
</article>
</div>
<aside class="sidebar">
<section>
  <h1>近期文章</h1>
  <ul id="recent_posts">
  
  
      <li class="post">
        <a href="/article/2015/09/oracle-comma-separate-field/">Oracle逗号分隔字段</a>
      </li>
      <li class="post">
        <a href="/article/2015/09/git-basic-operation/">GIT 使用的基本方法</a>
      </li>
      <li class="post">
        <a href="/article/2015/09/er-diagram/">ER图与UML图(暂且只是ER图)</a>
      </li>
      <li class="post">
        <a href="/article/2015/09/some-resources/">一些资源</a>
      </li>
      <li class="post">
        <a href="/article/2015/08/free-hosting/">免费二级域名/主机</a>
      </li>
  </ul>
</section>

<section>
  <h1>分类</h1>
  <ul id="categories">
	<li class="category"><a href="/category/software/">软件应用</a><span class="count right">5</span>
	    <ul class="children1">
	<li class="category"><a href="/category/software/dev/">开发用的软件</a><span class="count right">3</span>
	</li>
	<li class="category"><a href="/category/software/software_with_sn/">破解版软件</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/software/windows/">Windows应用技巧</a><span class="count right">1</span>
	</li>
    </ul>
</li>
	<li class="category"><a href="/category/tech/">编程开发</a><span class="count right">5</span>
	    <ul class="children1">
	<li class="category"><a href="/category/tech/java/">Java</a><span class="count right">5</span>
	    <ul class="children2">
	<li class="category"><a href="/category/tech/java/framework/">Java框架</a><span class="count right">4</span>
	    <ul class="children3">
	<li class="category"><a href="/category/tech/java/framework/spring/">Java框架-Spring</a><span class="count right">4</span>
	</li>
	<li class="category"><a href="/category/tech/java/framework/struts2/">Java框架-Struts2</a><span class="count right">3</span>
	</li>
    </ul>
</li>
	<li class="category"><a href="/category/tech/java/javaweb/">JavaWeb</a><span class="count right">3</span>
	</li>
    </ul>
</li>
	<li class="category"><a href="/category/tech/webFront/">web前端</a><span class="count right">2</span>
	    <ul class="children2">
	<li class="category"><a href="/category/tech/webFront/javascript/">JavaScript</a><span class="count right">4</span>
	</li>
    </ul>
</li>
    </ul>
</li>
	<li class="category"><a href="/category/website/">网站建设</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/opoopress/">opoopress</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/blog/">blog</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/you-xiu-bo-ke/">优秀博客</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/bo-ke/">博客</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/lu-xian-tu/">路线图</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/this_is_life/">this_is_life</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/git/">git</a><span class="count right">1</span>
	</li>
	<li class="category"><a href="/category/oracle/">Oracle</a><span class="count right">1</span>
	</li>
  </ul>
</section>
</aside>
    </div>
  </div>
  <footer role="contentinfo"><p>
  版权所有 &copy; 2015 - <a href='https://github.com/yafey'>YaFey</a> -
  <span class="credit">Powered by <a href="http://www.opoopress.com/">OpooPress</a></span>
</p></footer>
<script type="text/javascript" src="/javascripts/opoopress.min.js"></script>
<script language="JavaScript">
<!--
    window.OpooPress = new OpooPressApp({siteUrl:'http://yoursite.com',rootUrl:'',pageUrl:'/article/2015/02/spring4.0-notes-shangguigu-jdbc-transaction/',title:'Spring4.0学习笔记@尚硅谷 之 JDBC部分(含事务管理) (3/n)',refreshRelativeTimes:true,verbose:true},{});
    OpooPress.init();

//-->
</script>
<!-- START: Syntax Highlighter ComPress -->
<script type="text/javascript" src="/plugins/syntax-highlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="/plugins/syntax-highlighter/scripts/shAutoloader.js"></script>
<script type="text/javascript">
    SyntaxHighlighter.autoloader(
        'applescript			/plugins/syntax-highlighter/scripts/shBrushAppleScript.js',
        'actionscript3 as3		/plugins/syntax-highlighter/scripts/shBrushAS3.js',
        'bash shell				/plugins/syntax-highlighter/scripts/shBrushBash.js',
        'coldfusion cf			/plugins/syntax-highlighter/scripts/shBrushColdFusion.js',
        'cpp c					/plugins/syntax-highlighter/scripts/shBrushCpp.js',
        'c# c-sharp csharp		/plugins/syntax-highlighter/scripts/shBrushCSharp.js',
        'css					/plugins/syntax-highlighter/scripts/shBrushCss.js',
        'delphi pascal pas		/plugins/syntax-highlighter/scripts/shBrushDelphi.js',
        'diff patch			    /plugins/syntax-highlighter/scripts/shBrushDiff.js',
        'erl erlang				/plugins/syntax-highlighter/scripts/shBrushErlang.js',
        'groovy					/plugins/syntax-highlighter/scripts/shBrushGroovy.js',
        'java					/plugins/syntax-highlighter/scripts/shBrushJava.js',
        'jfx javafx				/plugins/syntax-highlighter/scripts/shBrushJavaFX.js',
        'js jscript javascript	/plugins/syntax-highlighter/scripts/shBrushJScript.js',
        'perl pl				/plugins/syntax-highlighter/scripts/shBrushPerl.js',
        'php					/plugins/syntax-highlighter/scripts/shBrushPhp.js',
        'text plain				/plugins/syntax-highlighter/scripts/shBrushPlain.js',
        'powershell ps          /plugins/syntax-highlighter/scripts/shBrushPowerShell.js',
        'py python				/plugins/syntax-highlighter/scripts/shBrushPython.js',
        'ruby rails ror rb		/plugins/syntax-highlighter/scripts/shBrushRuby.js',
        'sass scss              /plugins/syntax-highlighter/scripts/shBrushSass.js',
        'scala					/plugins/syntax-highlighter/scripts/shBrushScala.js',
        'sql					/plugins/syntax-highlighter/scripts/shBrushSql.js',
        'vb vbnet				/plugins/syntax-highlighter/scripts/shBrushVb.js',
        'xml xhtml xslt html	/plugins/syntax-highlighter/scripts/shBrushXml.js'
    );
    SyntaxHighlighter.defaults['auto-links'] = false;                 
    SyntaxHighlighter.defaults['toolbar'] = false;     
    SyntaxHighlighter.defaults['tab-size'] = 4;
    SyntaxHighlighter.all();
</script>
<!-- END: Syntax Highlighter ComPress -->
</body>
</html>

