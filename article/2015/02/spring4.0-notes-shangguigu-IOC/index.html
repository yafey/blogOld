<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="zh"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Spring4.0学习笔记@尚硅谷 之 IOC部分 (1/n) - YaFey 的博客</title>
  <meta name="author" content="<a href='https://github.com/yafey'>YaFey</a>">
  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="OpooPressSiteRoot" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="Generator" content="OpooPress-1.1.1"/>
  <meta name="Generated" content="2015-08-31T00:33:19+08:00"/>
  <link rel="canonical" href="/article/2015/02/spring4.0-notes-shangguigu-IOC/">
  
  
  <link href="/favicon.ico" rel="icon">
  <link href="/atom.xml" rel="alternate" title="YaFey 的博客" type="application/atom+xml">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic|PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link type="text/css" rel="stylesheet" href="/plugins/syntax-highlighter/styles/shCoreDefault.css"/>
  <!--[if lt IE 9]><script src="/javascripts/html5shiv.js"></script><![endif]-->
</head>
<body class="no-sidebar">
  <!--[if lt IE 9]><script src="/javascripts/unsupported-browser.js"></script><![endif]-->
  <header role="banner"><hgroup>
  <h1><a href="/">YaFey 的博客</a></h1>
    <h2>记录点点滴滴</h2>
</hgroup>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:http://yoursite.com" />
    <input class="search" type="text" name="q" results="0" placeholder="搜索"/>
  </fieldset>
</form>
<fieldset class="mobile-nav">
  <select onchange="if (this.value) { window.location.href = this.value;}">
    <option value="">导航&hellip;</option>
    <option value="/">&raquo; 文章</option>
    <option value="/archives/">&raquo; 归档</option>
    <option value="/category/">&raquo; 分类</option>
    <option value="/sample-page.html">&raquo; 示例页面</option>
    <option value="/about/">&raquo; 关于</option>
  </select>
</fieldset>

<ul class="main-navigation">
<li><a href="/">文章</a></li>
<li><a href="/archives/">归档</a></li>
<li><a href="/category/">分类</a></li>
<li><a href="/sample-page.html">示例页面</a></li>
<li><a href="/about/">关于</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
<div>
<article class="hentry" role="article">
  <header>
      <h1 class="entry-title">Spring4.0学习笔记@尚硅谷 之 IOC部分 (1/n)</h1>

      <p class="meta">
		


<time datetime="2015-02-07T00:06:00+08:00" pubdate>2015年02月07日 00:06:00</time>
      </p>
  </header>

  <div class="entry-content"><blockquote><h1>目录</h1>
<ul>
<li><a href="#1.helloworld-in-spring">1. Hello World in Spring (What)</a><ul>
<li>1.1.Spring 是什么</li>
<li>1.2.具体描述 Spring</li>
<li>1.3. Spring 模块</li>
<li>1.4. 安装 SPRING TOOL SUITE</li>
<li>1.5. 搭建 Spring 开发环境 及 建立 Spring-helloworld 项目<ul>
<li>1.5.1. 建立 Spring 项目</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2.bean_config">2. Spring 中的 Bean 配置</a><ul>
<li><a href="#2.1.IOC_and_DI">2.1.IOC 和 DI , 描述的是同一回事</a></li>
<li>2.2. IOC 前世今生<ul>
<li>2.2.1. IOC 前生 &mdash; 分离接口与实现</li>
<li>2.2.2. IOC 前生 &mdash; 采用工厂设计模式</li>
<li>2.2.3. IOC &mdash; 采用反转控制 ， （DI,依赖注入， 容器根据依赖关系自动注入）</li>
</ul>
</li>
<li><a href="#2.3.ioc-bean-deploy">2.3. 在 Spring 的 IOC 容器里配置 Bean</a></li>
<li><a href="#2.4.Spring-ioc">2.4.Spring 容器 (IOC 容器 BeanFactory &amp; ApplicationContext 概述)</a><ul>
<li>2.4.1.ApplicationContext 及主要实现类</li>
<li>2.4.2. 从 IOC 容器中获取 Bean</li>
</ul>
</li>
<li><a href="#2.5.DI-types">2.5.依赖注入的方式</a><ul>
<li><a href="#2.5.1.DI-setter">2.5.1.属性注入</a></li>
<li><a href="#2.5.2.DI-constructor">2.5.2.构造方法注入</a></li>
</ul>
</li>
<li><a href="#2.6.DI-detail"><strong>2.6. 注入属性值细节</strong></a><ul>
<li><a href="#2.6.1.ref-bean">2.6.1.引用其它 Bean</a></li>
<li><a href="#2.6.2.null-and-cascade">2.6.2.注入参数详解：null 值和级联属性</a></li>
<li><a href="#2.6.3.collections-types">2.6.3.集合属性</a></li>
<li><a href="#2.6.4.collections-util-scheme">2.6.4.使用 utility scheme 定义集合 &ndash; 为了复用</a></li>
<li><a href="#2.6.5.p-namespace">2.6.5.使用 p 命名空间 &ndash;简化,属性 代替子元素</a></li>
</ul>
</li>
<li><a href="#2.7.xml-autowire">2.7. XML 配置里的 Bean 自动装配 </a> (byName,byType,<em>constructor</em>) 及 自动装配的缺点</li>
<li><a href="#2.8.beans-relation">2.8. bean 之间的关系：(配置上的)继承；依赖</a></li>
<li><a href="#2.9.beans-workspace-environment">2.9, bean 的作用域：singleton；prototype；WEB 环境作用域</a></li>
<li><a href="#2.10.bean-use-outer-properties">2.10, 使用外部属性文件</a></li>
<li><a href="#2.11.spEL">2.11, Spring表达式语言：SpEL</a><ul>
<li>SpEL 的语法<strong>更详细版</strong> 参考 <a href="http://jinnianshilongnian.iteye.com/blog/1418309" target="_blank" title="外链-iteye">(开涛的博客)【第五章】Spring表达式语言 之 5.3 SpEL语法 ——跟我学spring3</a></li>
</ul>
</li>
<li><a href="#2.12.bean-life-in-IOC"><strong>2.12, IOC 容器中 Bean 的生命周期</strong></a><ul>
<li>2.12.1. IOC 容器中 Bean 的生命周期方法</li>
<li>2.12.2. 创建 Bean 后置处理器</li>
</ul>
</li>
<li><a href="#2.13.bean-config-static-factory-new-instance">2.13, Bean 的配置方式：通过工厂方法（静态工厂方法 &amp; 实例工厂方法）</a><ul>
<li>2.13.1. 通过调用静态工厂方法创建 Bean</li>
<li>2.13.2. 通过调用实例工厂方法创建 Bean</li>
</ul>
</li>
<li><a href="#2.14.bean-config-factory-bean">2.14.Bean 的配置方式：实现 FactoryBean 接口在 Spring IOC 容器中配置 Bean</a><ul>
<li><em>(配置 bean 的时候需要使用到 IOC 容器中的 其他 Bean&mdash;使用 Spring 的 FactoryBean 最合适).</em></li>
</ul>
</li>
<li><a href="#2.15.spring-annotation-scan"><strong>2.15, Bean 的配置形式：基于注解的方式（基于注解配置 Bean；基于注解来装配 Bean 的属性）</strong></a><ul>
<li><a href="#2.15.1.spring-annotation-scan-component">2.15.1. 在 classpath 中扫描组件 (<em>基于注解配置 Bean</em>)</a></li>
<li><a href="#2.15.2.spring-annotation-scan-resource">2.15.2. 组件属性装配 (<em>基于注解来装配 Bean 的属性</em>)</a></li>
</ul>
</li>
<li><a href="#2.16.new-feature-in-Spring-4.x">2.16, Spring 4.x 新特性：泛型依赖注入</a></li>
<li><a href="#2.17.many-to-one-config"><strong>2.17, 整合多个配置文件</strong></a></li>
</ul>
</li>
</ul>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><a href="http://projects.spring.io/spring-framework/" title="http://projects.spring.io/spring-framework/">Spring下载页面</a></p>
<ul>
<li>(版本更新说明) 3.2 &ndash;> 4.0 ,有重大升级,添加了许多使用的功能.</li>
<li>(很多框架的下载方式推荐使用 Maven 的下载方式), Spring 也不例外.</li>
</ul>
<p>Spring4.0 是 Spring 推出的一个重大版本升级，进一步加强了 Sring 作为 Java 领域第一开源平台的地位。Spring4.0 引入了众多 Java 开发者期盼的新特性，如<strong>泛型依赖注入、SpEL、校验及格式化框架、Rest风格的 WEB 编程模型</strong>等。这些新功能实用性强、易用性高，可大幅降低 JavaEE 开发的难度，同时有效提升应用开发的优雅性。
佟老师在课程的讲授过程中，多次深入剖析 Spring 源代码、让学员知其然更知其所以然。授课过程中的代码非常经典，部分代码更是可以直接应用到企业开发中。
本套视频适合有 Java 基础的学员学习。学习完本套视频不但可以使学员掌握 Spring4.0 的核心技术，更能使学员的 Java 技术水平有一个非常大的提升！</p>
</blockquote>
<h1><span id="1.helloworld-in-spring">1. Hello World in Spring (What)</span></h1>
<h2>1.1.Spring 是什么</h2>
<ul>
<li>Spring 是一个开源框架.</li>
<li>Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能.</li>
<li>Spring 是一个 <strong>IOC(DI)</strong>反转控制(依赖注入) 和 <strong>AOP</strong> 容器框架.</li>
</ul>
<h2>1.2.具体描述 Spring</h2>
<ul>
<li><strong>轻量级：Spring 是非侵入性的</strong> - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API</li>
<li><strong>依赖注入(DI &mdash; dependency injection、IOC)</strong></li>
<li><strong>面向切面编程(AOP &mdash; aspect oriented programming)</strong></li>
<li><strong>容器: </strong>Spring 是一个容器, 因为它包含并且管理应用对象的生命周期</li>
<li><strong>框架:</strong> Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象</li>
<li><strong>一站式：</strong>在 IOC 和 AOP 的基础上<strong>可以整合各种</strong>企业应用的<strong>开源框架</strong>和<strong>优秀的第三方类库</strong> （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）</li>
</ul>
<h2>1.3. Spring 模块</h2>
<p><img src="/blog_images/program/spring4.0/spring-models.gif" alt="Spring 模块" /></p>
<h2>1.4. 安装 SPRING TOOL SUITE</h2>
<p><img src="/blog_images/program/spring4.0/eclipse-install-springsource_tool_suite.jpg" alt="Spring 模块" />
<img src="/blog_images/program/spring4.0/eclipse-install-springsource_tool_suite-step-by-step.gif" alt="Spring 模块" /></p>
<h2>1.5. 搭建 Spring 开发环境 及 建立 Spring-helloworld 项目</h2>
<ol>
<li>把<strong>以下 jar 包加入到工程的 classpath 下</strong>:
<img src="/blog_images/program/spring4.0/spring-core-jars.jpg" alt="Spring 模块" /></li>
<li><strong>Spring 的配置文件</strong>: 一个典型的 Spring 项目需要创建一个或多个 Bean 配置文件, 这些配置文件用于在 Spring IOC 容器里配置 Bean. <strong>Bean 的配置文件可以放在 classpath 下, 也可以放在其它目录下.</strong></li>
</ol>
<h3>1.5.1. 建立 Spring 项目</h3>
<blockquote><p>HelloWorld.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld;
public class HelloWorld {
    private String user;
    public HelloWorld() {
        System.out.println("HelloWorld's constructor...");
    }
    public void setUser2(String user) {
        System.out.println("setUser:" + user);
        this.user = user;
    }
    public HelloWorld(String user) {
        this.user = user;
    }
    public void hello(){
        System.out.println("Hello: " + user);
    }
}
</pre><p>applicationContext.xml  &mdash;- 放在 src 目录下</p>
<pre class='brush:xml'>    &lt;bean id="helloWorld" class="com.yafey.spring.helloworld.HelloWorld"&gt;
        &lt;property name="user2" value="Spring"&gt;&lt;/property&gt;
        &lt;!-- property name对应的是 setXXX 方法 --&gt;
    &lt;/bean&gt;
</pre><p>Main.java 主方法</p>
<pre class='brush:java'>package com.yafey.spring.helloworld;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Main {
    public static void main(String[] args) {
//      HelloWorld helloWorld = new HelloWorld();
//      helloWorld.setUser("Tom");
//      helloWorld.hello(); 
        //1. 创建 Spring 的 IOC 容器
        // 创建容器的时候,会根据配置的 bean , 调用 其构造方法,及 setXXX 方法 赋值.
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //2. 从 IOC 容器中获取 bean 的实例
//      HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld");
        //3. 使用 bean
//      helloWorld.hello();
    }
}
</pre><p>输出 :</p>
<pre class='brush:java'>HelloWorld's constructor...
setUser:Spring
</pre></blockquote>
<h1>2. <span id="2.bean_config">Spring 中的 Bean 配置</span></h1>
<blockquote><ul>
<li>IOC &amp; DI 概述</li>
<li>配置 bean<ul>
<li>配置形式：基于 XML 文件的方式；基于注解的方式</li>
<li>Bean 的配置方式：通过全类名（反射）、通过工厂方法（静态工厂方法 &amp; 实例工厂方法）、FactoryBean</li>
<li>IOC 容器 BeanFactory &amp; ApplicationContext 概述</li>
<li>依赖注入的方式：属性注入；构造器注入</li>
<li>注入属性值细节</li>
<li>自动装配</li>
<li>bean 之间的关系：继承；依赖</li>
<li>bean 的作用域：singleton；prototype；WEB 环境作用域</li>
<li>使用外部属性文件</li>
<li>spEL</li>
<li>IOC 容器中 Bean 的生命周期</li>
<li>Spring 4.x 新特性：泛型依赖注入</li>
</ul>
</li>
</ul>
</blockquote>
<h2>2.1. <span id="2.1.IOC_and_DI">IOC 和 DI , 描述的是同一回事</span></h2>
<ul>
<li><strong>IOC(Inversion of Control,控制反转)</strong>：其思想是<strong>反转资源获取的方向</strong>. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, <strong>则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源</strong>. 这种行为也被称为查找的被动形式.</li>
<li><strong>DI(Dependency Injection,依赖注入)</strong> — IOC 的另一种表述方式：<strong>即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入</strong>. 相对于 IOC 而言，这种表述更直接.</li>
</ul>
<p><img src="/blog_images/program/spring4.0/IOC-DI-demo.jpg" alt="IOC和DI示例" title="IOC和DI示例" /></p>
<h2>2.2. IOC 前世今生</h2>
<p>需求: 生成 HTML 或 PDF 格式的不同类型的报表.</p>
<h3>2.2.1. IOC 前生 &mdash; 分离接口与实现</h3>
<p>最传统的方式:耦合度最高.(<em>Service 要画出 3 条线.</em>) <br />
在 Service 中 需要知道 报表生成器(接口) 及 具体有哪几个实现类的细节.<br />
(<em>例子: 远古时代,需要自己打造一把斧子.</em>)
<img src="/blog_images/program/spring4.0/IOC-prev-now-1-inter-and-impl.png" alt="IOC 前生 --- 分离接口与实现" title="IOC 前生 --- 分离接口与实现" /></p>
<h3>2.2.2. IOC 前生 &mdash; 采用工厂设计模式</h3>
<p>耦合度降低(<em>Service 要画出 2 条线.</em>)。<br />
Service 中 ，只需要知道 接口 及 工厂类 ， 在工厂类中实现了具体的实现细节（Service不关心）。<br />
（<em>例子：封建社会，只需要去打铁店购买一把斧子。</em>）
<img src="/blog_images/program/spring4.0/IOC-prev-now-2-inter-and-factory.png" alt="IOC 前生 --- 采用工厂设计模式" title="IOC 前生 --- 采用工厂设计模式" /></p>
<h3>2.2.3. IOC &mdash; 采用反转控制 ， （DI,依赖注入， 容器根据依赖关系自动注入）</h3>
<p>IOC 方式 的 耦合度极低。（<em>Service 只需要画一条线</em>）<br />
Service 中 ， 只需要指明需要的类型。（容器会根据配置，分配给 Service 对应的类型。）<br />
（<em>例子：半奴隶社会，按需分配。</em>）
<img src="/blog_images/program/spring4.0/IOC-prev-now-3-IOC.png" alt="IOC --- 采用反转控制" title="IOC --- 采用反转控制 " /></p>
<h2><span id="2.3.ioc-bean-deploy">2.3. 在 Spring 的 IOC 容器里配置 Bean (XML方式)</span></h2>
<ul>
<li>在 xml 文件中通过 bean 节点来配置 bean<ul>
<li>class : <strong>bean 的 全类名</strong> , 通过反射的方式在 IOC 容器中创建 Bean , 所以<strong>要求 Bean 中必须有 无参的构造函数</strong>.</li>
<li>id：Bean 的名称。<ul>
<li><strong>在 IOC 容器中必须是唯一的</strong></li>
<li>若 id 没有指定，Spring 自动将<strong>全写类名（带包名）</strong>作为 Bean 的名字
示例 : <code>HelloWorld helloWorld = (HelloWorld) ctx.getBean("com.yafey.spring.helloworld.HelloWorld");</code></li>
<li>~~id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔~~(<strong>待核实</strong>,未测试成功.)<pre class='brush:xml'>&lt;!-- 配置 bean :
class : bean 的 全类名 , 通过反射的方式在 IOC 容器中创建 Bean , 所以要求 Bean 中必须有 无参的构造函数.
id : 标识容器中的 bean , id 必须唯一.
--&gt;
&lt;bean id="helloWorld" class="com.yafey.spring.helloworld.HelloWorld"&gt;
&lt;/bean&gt;
</pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="2.4.Spring-ioc">2.4.Spring 容器 (IOC 容器 BeanFactory &amp; ApplicationContext 概述)</span></h2>
<ul>
<li>在 <strong>Spring IOC</strong> 容器读取 Bean 配置创建 Bean 实例之前, 必须对它进行实例化. 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用.</li>
<li><strong>Spring 提供了两种类型的 IOC 容器实现</strong>.<ul>
<li><code>BeanFactory</code>: IOC 容器的基本实现.</li>
<li><code>ApplicationContext</code>: 提供了更多的高级特性. 是 BeanFactory 的子接口.</li>
<li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；<strong>ApplicationContext 面向使用 Spring 框架的开发者</strong>，<strong>几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory</strong></li>
<li>无论使用何种方式, 配置文件是相同的.</li>
</ul>
</li>
</ul>
<h3>2.4.1.ApplicationContext 及主要实现类</h3>
<p><strong><code>ApplicationContext</code> 在初始化上下文时就实例化所有<code>单例的</code> Bean。</strong>
ApplicationContext 的主要实现类：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>：从 <strong>类路径下</strong>加载配置文件</li>
<li><code>FileSystemXmlApplicationContext</code>: 从<strong>文件系统</strong>中加载配置文件</li>
<li><code>ConfigurableApplicationContext</code> : 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力</li>
<li><code>WebApplicationContext</code> 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作</li>
</ul>
<p><img src="/blog_images/program/spring4.0/application-major-implements.png" alt="ApplicationContext 及主要实现类" title="ApplicationContext 及主要实现类" /></p>
<h3>2.4.2. 从 IOC 容器中获取 Bean</h3>
<p>调用 ApplicationContext 的 getBean() 方法 (<em>定义在 ApplicationContext 的 父接口 BeanFactory 接口</em>)</p>
<p><img src="/blog_images/program/spring4.0/applicationContext-getBean-method.png" alt="ApplicationContext 的 getBean() 方法" title="ApplicationContext 的 getBean() 方法" /></p>
<h2><span id="2.5.DI-types">2.5.依赖注入的方式</span></h2>
<p>Spring 支持 3 种依赖注入的方式</p>
<ul>
<li><strong>属性注入</strong></li>
<li><strong>构造器注入</strong></li>
<li>~~工厂方法注入~~（很少使用，不推荐）</li>
</ul>
<h3><span id="2.5.1.DI-setter">2.5.1.属性注入</span></h3>
<ul>
<li>属性注入即通过 <strong><code>setter 方法</code></strong> 注入Bean 的属性值或依赖的对象</li>
<li>属性注入使用 <property> 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 <value> 子节点指定属性值</li>
<li><strong>属性注入是实际应用中最常用的注入方式</strong></li>
</ul>
<pre class='brush:java'>// applicationContext.xml 中配置信息
&lt;bean id="helloWorld" class="com.yafey.spring.helloworld.HelloWorld"&gt;
    &lt;property name="user" value="yafey"&gt;&lt;/property&gt;
&lt;/bean&gt;
// Java Bean 中对象的 属性
public class HelloWorld{
    private String name;  //name 是 HelloWorld 的 成员变量
    public void setUser(String user){   // user 才是 HelloWorld 的 属性.
        name = user;
    }
}
</pre><h3><span id="2.5.2.DI-constructor">2.5.2.构造方法注入</span></h3>
<ul>
<li>通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。</li>
<li>构造器注入在 <constructor-arg> 元素里声明属性, <strong><constructor-arg> 中没有 name 属性</strong></li>
<li>按索引匹配入参</li>
<li>按类型匹配入参</li>
</ul>
<p>定义的 Java Bean , 其中包含 2 个重载的构造方法.</p>
<pre class='brush:java'>package com.yafey.spring.helloworld;

public class Car {

    private String company;
    private String brand;
    private int maxSpeed;
    private float price;

    public Car(String company, String brand, float price) {
        super();
        this.company = company;
        this.brand = brand;
        this.price = price;
    }

    public Car(String company, String brand, int maxSpeed) {
        super();
        this.company = company;
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    @Override
    public String toString() {
        return "Car [company=" + company + ", brand=" + brand + ", maxSpeed="
                + maxSpeed + ", price=" + price + "]";
    }
}
</pre><p>applicationContext.xml 中的配置</p>
<pre class='brush:xml'>&lt;!-- 通过构造器来配置 bean 的属性 --&gt;
&lt;!-- 可以根据 index 和 value 进行更加精确的定位. (可以混合使用) --&gt;
&lt;bean id="car" class="com.yafey.spring.helloworld.Car"&gt;
    &lt;constructor-arg value="奥迪" index="1"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value="长春一汽" index="0"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value="500000" type="float"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!-- 使用构造器注入属性值可以指定参数的位置和参数的类型！ 以区分重载的构造器！ --&gt;
&lt;bean id="car2" class="com.yafey.spring.helloworld.Car"&gt;
    &lt;constructor-arg value="长安马自达"&gt;&lt;/constructor-arg&gt;
    &lt;!-- 若字面值中包含特殊字符, 则可以使用 DCDATA 来进行赋值. (了解) --&gt;
    &lt;constructor-arg&gt;
        &lt;value&gt;&lt;![CDATA[&lt;ATARZA&gt;]]&gt;&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg value="180" type="int"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre><p>在 测试类 中的 main 方法中的代码</p>
<pre class='brush:java'>ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
Car car = (Car) ctx.getBean("car");
System.out.println(car);
car = (Car) ctx.getBean("car2");
System.out.println(car);
//输出结果 : 正确的区分了 maxSpeed 和 price
//Car [company=长春一汽, brand=奥迪, maxSpeed=0, price=500000.0]
//Car [company=长安马自达, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0]
</pre><h2><span id="2.6.DI-detail">2.6. 注入属性值细节</span></h2>
<ul>
<li><strong>字面值</strong>：可用字符串表示的值，可以<strong>通过 <value> 元素标签</strong>或 <strong>value 属性</strong>进行注入。
基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式</li>
<li><strong>若字面值中包含特殊字符，可以使用 <code>&lt;![CDATA[]]&gt;</code> 把字面值包裹起来</strong>。</li>
</ul>
<h3><span id="2.6.1.ref-bean">2.6.1.引用其它 Bean</span></h3>
<ul>
<li>组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能. <strong>要使 Bean 能够相互访问</strong>, 就必须在 Bean 配置文件中指定对 Bean 的引用</li>
<li>在 Bean 的配置文件中, 可以通过 <strong><ref> 元素或 ref  属性</strong>为 Bean 的属性或构造器参数指定对 Bean 的引用.</li>
<li>也可以<strong>在属性或构造器里包含 Bean 的声明</strong>, 这样的 Bean 称为<strong>内部 Bean</strong>.<ul>
<li>当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. <strong>内部 Bean 声明</strong>直接包含在 <property> 或 <constructor-arg> 元素里, <strong>不需要设置任何 id 或 name 属性</strong></li>
<li><strong>内部 Bean 不能使用在任何其他地方</strong></li>
</ul>
</li>
</ul>
<p>属性中包含其他类型的对象引用 , 且该类型在容器中已经定义 (复用上面的 Car类型)</p>
<pre class='brush:java'>package com.yafey.spring.helloworld;

public class Person {
    private String name;
    private Car car ;
    public void setName(String name) {
        this.name = name;
    }
    public void setCar(Car car) {
        this.car = car;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", car=" + car + "]";
    }

}
</pre><p><strong>xml中配置</strong></p>
<pre class='brush:xml'>&lt;!-- 引用其它 Bean --&gt;
&lt;bean id="person" class="com.yafey.spring.helloworld.Person"&gt;
    &lt;property name="name" value="Tom"&gt;&lt;/property&gt;
    &lt;!-- 可以通过 ref 属性 或 &lt;ref&gt;元素 简历 bean 之间的引用关系. --&gt;
    &lt;property name="car" ref="car2"&gt;&lt;/property&gt;
    &lt;!-- &lt;property name="car" &gt;
        &lt;ref bean="car2"/&gt;
    &lt;/property&gt; --&gt;
&lt;/bean&gt;
&lt;!-- 引用其它 Bean, 使用 内部 Bean --&gt;
&lt;bean id="person2" class="com.yafey.spring.helloworld.Person"&gt;
    &lt;property name="name" value="Tom"&gt;&lt;/property&gt;
    &lt;!-- 内部 Bean , 不能被外部引用,只能在内部使用, id属性可以忽略(其实就是无效的) --&gt;
    &lt;property name="car"&gt;
        &lt;bean id="car3" class="com.yafey.spring.helloworld.Car"&gt;
            &lt;constructor-arg value="奥迪-内部bean" index="1"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="长春一汽-内部bean" index="0"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="333000" type="float"&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 使用 构造方式 注入其他bean的配置 省略, 结合 构造方式 + 上面的引用 或 内部Bean的方式 --&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>//引用其它 Bean
Person per = (Person) ctx.getBean("person");
System.out.println(per);
//输出:
//Person [name=Tom, car=Car [company=长安马自达, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0]]

// 引用其它 Bean ---- 内部 Bean 方式
Person person = (Person) ctx.getBean("person2");
System.out.println(person);
//输出:
//Person [name=Tom, car=Car [company=长春一汽-内部bean, brand=奥迪-内部bean, maxSpeed=0, price=333000.0]]
</pre><h3><span id="2.6.2.null-and-cascade">2.6.2.注入参数详解：null 值和级联属性</span></h3>
<ul>
<li>可以使用专用的 <code>&lt;null/&gt;</code> 元素标签为 Bean 的字符串或其它对象类型的属性注入 null 值。(虽然不用这样显式的指明 null 值.)</li>
<li>和 Struts、Hiberante 等框架一样，<strong>Spring 支持级联属性的配置</strong>。</li>
</ul>
<blockquote><p><code>&lt;null/&gt;</code>值
在 Person.java 中 添加 构造参数 (为使用构造方式配置)</p>
<pre class='brush:java'>// 添加了 有参构造函数 后,必须添加 无参构造函数.
public Person() {
    super();
}
public Person(String name, Car car) {
    super();
    this.name = name;
    this.car = car;
}
</pre><p>xml中配置 (同时使用构造方式)</p>
<pre class='brush:xml'>&lt;!-- 测试 &lt;null/&gt; 值 (同时使用构造方式)--&gt;
&lt;bean id="person_null" class="com.yafey.spring.helloworld.Person"&gt;
    &lt;constructor-arg value="Jerry" type="java.lang.String"&gt;&lt;/constructor-arg&gt;
    &lt;!-- 测试赋值 null --&gt;
    &lt;constructor-arg&gt; &lt;null/&gt; &lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>// 测试赋值 null
Person person_null = (Person) ctx.getBean("person_null");
System.out.println(person_null);
//输出:
//Person [name=Jerry, car=null]
</pre></blockquote>
<p>&nbsp;</p>
<blockquote><p>级联属性的配置
在 Car.java 中添加 setMaxSpeed 方法.</p>
<pre class='brush:java'>public void setMaxSpeed(int maxSpeed) {
    this.maxSpeed = maxSpeed;
}
</pre><p>在 Person.java 中 添加 getCar 方法.</p>
<pre class='brush:java'>public Car getCar() {
    return car;
}
</pre><p>xml 中配置</p>
<pre class='brush:xml'>&lt;!-- 测试 级联属性配置--&gt;
&lt;bean id="person_cascade" class="com.yafey.spring.helloworld.Person"&gt;
    &lt;constructor-arg value="Jerry"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt;
    &lt;!-- 为级联属性赋值 , 注意:属性需要先初始化后才可以为级联属性赋值,否则会有异常,和 Struts2 不同(Struts2会自动创建这个对象). --&gt;
    &lt;property name="car.maxSpeed" value="311"&gt;&lt;/property&gt;
    &lt;!-- 级联属性配置 在 内部Bean配置 中的使用 , 本例中需要将 构造器配置-修改成-属性配置 (构造函数的参数签名要一致) 
    &lt;property name="car"&gt;
        &lt;bean class="com.yafey.spring.helloworld.Car"&gt;
            &lt;constructor-arg value="奥迪-内部bean" index="1"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="长春一汽-内部bean" index="0"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="333000" type="float"&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="car.maxSpeed" value="322"&gt;&lt;/property&gt;
    --&gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法. (注意看 Car 的 MaxSpeed 属性是否为配置的值.)</p>
<pre class='brush:java'>// 测试 级联属性配置
Person person_cascade = (Person) ctx.getBean("person_cascade");
System.out.println(person_cascade);
// 输出: 
//Person [name=Jerry, car=Car [company=长春一汽, brand=奥迪, maxSpeed=333, price=500000.0]]
</pre></blockquote>
<h3><span id="2.6.3.collections-types">2.6.3.集合属性</span></h3>
<p>在 Spring中可以通过一组内置的 xml 标签(例如: <code>&lt;list&gt;, &lt;set&gt; 或 &lt;map&gt;)</code> 来配置集合属性.</p>
<ul>
<li><strong>配置 java.util.List 类型的属性</strong>, 需要指定 <code>&lt;list&gt;</code>  标签, 在标签里包含一些元素.<ul>
<li>这些标签可以通过 <code>&lt;value&gt;</code> 指定简单的常量值,</li>
<li>通过 <code>&lt;ref&gt;</code> 指定对其他 Bean 的引用.</li>
<li>通过<code>&lt;bean&gt;</code> 指定内置 Bean 定义.</li>
<li>通过 <code>&lt;null/&gt;</code> 指定空元素. 甚至可以内嵌其他集合.</li>
</ul>
</li>
<li><strong>数组的定义</strong>和 List 一样, 都使用 <code>&lt;list&gt;</code></li>
<li><strong>配置 java.util.Set 需要使用 <code>&lt;set&gt;</code> 标签,</strong> 定义元素的方法与 List 一样.</li>
<li><strong>Java.util.Map 通过 <map> 标签定义</strong>, <code>&lt;map&gt;</code> 标签里可以使用多个 <code>&lt;entry&gt;</code> 作为子标签. 每个条目包含一个键和一个值.<ul>
<li><strong>必须在 <code>&lt;key&gt; 标签</code>里定义键</strong></li>
<li>因为键和值的类型没有限制, 所以可以自由地为它们指定 <code>&lt;value&gt;, &lt;ref&gt;, &lt;bean&gt; 或 &lt;null&gt; 元素</code>.</li>
<li>可以将 Map 的<strong>键和值</strong>作为 <strong><code>&lt;entry&gt;</code> 的属性</strong>定义:<ul>
<li>简单常量使用 key 和 value 来定义;</li>
<li>Bean 引用通过 key-ref 和 value-ref 属性定义</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用 <code>&lt;props&gt;</code> 定义 java.util.Properties</strong>, 该标签使用多个 <code>&lt;prop&gt;</code> 作为子标签. 每个 <code>&lt;prop&gt;</code> 标签必须定义 key 属性.</li>
</ul>
<blockquote><p>集合属性&ndash;list 配置
新建 Person_list_car.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.collection;
import java.util.List;
import com.yafey.spring.helloworld.Car;
public class Person_list_car {
    private String name;
    private List&lt;Car&gt; cars ;
    // setter , getter 
    //... toString...
}
</pre><p>xml 配置</p>
<pre class='brush:xml'>&lt;!-- 测试如何配置集合属性-list  --&gt;
&lt;bean id="person_list_car" class="com.yafey.spring.helloworld.collection.Person_list_car"&gt;
    &lt;property name="name" value="Mike"&gt;&lt;/property&gt;
    &lt;property name="cars"&gt;
        &lt;list&gt;
            &lt;ref bean="car"&gt;&lt;/ref&gt;
            &lt;ref bean="car2"&gt;&lt;/ref&gt;
            &lt;bean class="com.yafey.spring.helloworld.Car"&gt;
            &lt;constructor-arg value="奥迪" index="1"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="长春一汽" index="0"&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg value="333000" type="float"&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>// 测试 集合属性--list
Person_list_car person_list_car = (Person_list_car) ctx.getBean("person_list_car");
System.out.println(person_list_car);
// 输出: 为了显示效果, 人为折行
//Person [name=Mike, cars=[
//  Car [company=长春一汽, brand=奥迪, maxSpeed=311, price=500000.0], 
//  Car [company=长安马自达, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0], 
//  Car [company=长春一汽, brand=奥迪, maxSpeed=0, price=333000.0]
//  ]
//]
</pre></blockquote>
<p>&nbsp;</p>
<blockquote><p>集合属性&ndash;map-properties 配置
新建 Person_map_car.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.collection;
import java.util.Map;
import java.util.Properties;
import com.yafey.spring.helloworld.Car;
public class Person_map_car {
    private String name;
    private Map&lt;String, Car&gt; cars;
    private Properties properties;
    // setter , getter 
    //... toString...
}
</pre><p>xml 配置</p>
<pre class='brush:xml'>&lt;!-- 测试如何配置集合属性-map-properties  --&gt;
&lt;bean id="person_map_car" class="com.yafey.spring.helloworld.collection.Person_map_car"&gt;
    &lt;property name="name" value="Rose"&gt;&lt;/property&gt;
    &lt;property name="cars"&gt;
        &lt;!-- 使用 map 节点及 map 的 entry 子节点配置 Map 类型的属性(有set/get方法的 成员变量) --&gt;
        &lt;map&gt;
            &lt;entry key="AA" value-ref="car"&gt;&lt;/entry&gt;
            &lt;entry key="BB" value-ref="car2"&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;!-- 使用 props 和 prop 子节点来为 Properties 属性赋值 --&gt;
        &lt;props&gt;
            &lt;prop key="user"&gt;root&lt;/prop&gt;
            &lt;prop key="password"&gt;123456&lt;/prop&gt;
            &lt;prop key="url"&gt;jdbc:mysql:///test&lt;/prop&gt;
            &lt;prop key="driverClass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>// 测试 集合属性--map--properties
Person_map_car person_map_car = (Person_map_car) ctx.getBean("person_map_car");
System.out.println(person_map_car);
// 输出: 为了显示效果, 人为折行
//Person_map_car [
//  name=Rose, 
//  cars={
//      AA=Car [company=长春一汽, brand=奥迪, maxSpeed=311, price=500000.0], 
//      BB=Car [company=长安马自达, brand=&lt;ATARZA&gt;, maxSpeed=180, price=0.0]
//  }, 
//  properties={driverClass=com.mysql.jdbc.Driver, user=root, url=jdbc:mysql:///test, password=123456}
//]
</pre></blockquote>
<h3><span id="2.6.4.collections-util-scheme">2.6.4.使用 utility scheme 定义集合 &ndash; 为了复用</span></h3>
<ul>
<li>使用基本的集合标签定义集合时, <strong>不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合.</strong></li>
<li>可以使用 util schema 里的集合标签定义独立的集合 Bean. 需要注意的是, 必须在 <code>&lt;beans&gt;</code> 根元素里添加 util schema 定义</li>
</ul>
<p><img src="/blog_images/program/spring4.0/applicationContext-add-namespace.gif" alt="Spring配置文件添加命名空间" title="Spring配置文件添加命名空间" /></p>
<blockquote><p>xml 配置</p>
<pre class='brush:xml'>&lt;!-- 配置单例的集合 bean util, 以供多个 bean 进行引用,需要导入 util 命名空间 --&gt;
&lt;util:list id="cars_list_util"&gt;
    &lt;ref bean="car" /&gt;
    &lt;ref bean="car2" /&gt;
    &lt;!-- 也可以使用 bean 标记 根据构造器方式或属性方式配置一个 bean --&gt;
&lt;/util:list&gt;
&lt;util:properties id="properties_util"&gt;
    &lt;prop key="user"&gt;root&lt;/prop&gt;
    &lt;prop key="password"&gt;123456&lt;/prop&gt;
    &lt;prop key="url"&gt;jdbc:mysql:///test&lt;/prop&gt;
    &lt;prop key="driverClass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
&lt;/util:properties&gt;
&lt;!-- 测试 配置单例的集合 bean util --&gt;
&lt;bean id="person_collection_util" class="com.yafey.spring.helloworld.collection.Person_list_car"&gt;
    &lt;property name="name" value="Jacky"&gt;&lt;/property&gt;
    &lt;property name="cars" ref="cars_list_util"&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>// 测试 配置单例的集合 bean util (注意,用的是 Person_list_car )
Person_list_car person_collection_util = (Person_list_car) ctx.getBean("person_collection_util");
System.out.println(person_collection_util);
// 输出结果 , 和上面的类似.
</pre></blockquote>
<h3><span id="2.6.5.p-namespace">2.6.5.使用 p 命名空间 &ndash;简化,属性 代替子元素</span></h3>
<ul>
<li>为了简化 XML 文件的配置，越来越多的 XML 文件<strong>采用属性而非子元素</strong>配置信息。</li>
<li>Spring 从 <strong>2.5 版本</strong>开始引入了一个<strong>新的 p 命名空间</strong>，可以通过 <strong><code>&lt;bean&gt;</code> 元素属性的方式配置 Bean 的属性</strong>。</li>
<li>使用 p 命名空间后，基于 XML 的配置方式将进一步简化</li>
</ul>
<blockquote><p>xml 配置</p>
<pre class='brush:xml'>&lt;!-- 通过 p 命名空间为 bean 的属性赋值, 需要先导入 p 命名空间 --&gt;
&lt;bean id="person_util_p" class="com.yafey.spring.helloworld.collection.Person_list_car" 
    p:name="Tomahs" p:cars-ref="cars_list_util" &gt;
&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>//通过 p 命名空间为 bean 的属性赋值 (注意,用的是 Person_list_car )
Person_list_car person_util_p = (Person_list_car) ctx.getBean("person_util_p");
System.out.println(person_util_p);
// 输出结果 , 和上面的类似.
</pre></blockquote>
<h2><span id="2.7.xml-autowire">2.7. XML 配置里的 Bean 自动装配</span></h2>
<blockquote><p>之前配置 bean 是手工指定装配 , 通过指定 值 或 引用.</p>
</blockquote>
<ul>
<li><strong>Spring IOC 容器可以自动装配 Bean</strong>. 需要做的仅仅是<strong>在 <code>&lt;bean&gt;</code> 的 autowire 属性里指定自动装配的模式</strong><ul>
<li><strong><code>byType</code>(根据类型自动装配)</strong>: 若 IOC 容器中有多个与目标 Bean 类型一致的 Bean. 在这种情况下, Spring 将无法判定哪个 Bean 最合适该属性, 所以不能执行自动装配.</li>
<li><strong><code>byName</code>(根据名称自动装配)</strong>: 必须将目标 Bean 的名称和属性名设置的完全相同.</li>
<li>~~<em><code>constructor</code>(通过构造器自动装配)</em>~~: 当 Bean 中存在多个构造器时, 此种自动装配方式将会很复杂. <strong>不推荐使用</strong></li>
</ul>
</li>
<li>XML 配置里的 Bean <strong>自动装配的缺点</strong><ul>
<li>在 Bean 配置文件里设置 autowire 属性进行自动装配将会装配 Bean 的所有属性. 然而, <strong>若只希望装配个别属性时, autowire 属性就不够灵活了</strong>.</li>
<li>autowire 属性<strong>要么根据类型自动装配, 要么根据名称自动装配, 不能两者兼而有之</strong>.</li>
<li>一般情况下，在<strong>实际的项目中很少使用自动装配功能</strong>，因为和自动装配功能所带来的好处比起来，<strong>明确清晰的配置文档更有说服力一些</strong></li>
</ul>
</li>
</ul>
<blockquote><p>省略 定义 bean 的 java 文件 (Address.java , Person_autowire.java)<br />
xml文件 (新建的 beans-autowire.xml)</p>
<pre class='brush:xml'>&lt;bean id="car" class="com.yafey.spring.helloworld.Car" p:brand="大众"
    p:company="一汽集团"&gt;&lt;/bean&gt;
&lt;bean id="address" class="com.yafey.spring.helloworld.autowire.Address"
    p:city="杭州" p:street="江干区"&gt;&lt;/bean&gt;
&lt;!-- 普通方式配置 --&gt;
&lt;!-- &lt;bean id="person_normal" class="com.yafey.spring.helloworld.autowire.Person_autowire" 
    p:name="zhangsan" p:car-ref="car" p:address-ref="address"&gt;&lt;/bean&gt; 
--&gt;
&lt;!-- 
    可以使用 autowire 属性指定自动装配的方式,
    byName 根据 bean 的名字和当前 bean 的 setter 风格的属性名进行自动装配, 
        若有匹配, 则进行装配 ; 若没有匹配的, 则不装配.
    byType 根据 bean 的类型和当前 bean 的属性的类型进行自动装配 . 
        若 IOC 容器中有 2个以上(含2个) 的类型匹配的 bean ,则抛异常.
--&gt;
&lt;bean id="person_autowire" class="com.yafey.spring.helloworld.autowire.Person_autowire"
    p:name="zhangsan" autowire="byName"&gt;&lt;/bean&gt;
</pre><p>测试类的 main 方法.</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.autowire;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class AutowireTest {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-autowire.xml");
        Person_autowire person_autowire = (Person_autowire) ctx.getBean("person_autowire");
        System.out.println(person_autowire);
    }
}
// 输出:
//Person_autowire [name=zhangsan, car=Car [company=一汽集团, brand=大众, maxSpeed=0, price=0.0], address=Address [city=杭州, street=江干区]]
</pre></blockquote>
<h2><span id="2.8.beans-relation">2.8. bean 之间的关系：(配置上的)继承；依赖</span></h2>
<ul>
<li><strong>继承 Bean 配置</strong><ul>
<li><strong>Spring 允许继承 bean 的配置</strong>, 被继承的 bean 称为父 bean. 继承这个父 Bean 的 Bean 称为子 Bean</li>
<li><strong>子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置</strong><ul>
<li><strong>并不是 <code>&lt;bean&gt;</code> 元素里的所有属性都会被继承</strong>. 比如: autowire, abstract 等.</li>
<li>子 Bean 也可以<strong>覆盖</strong>从父 Bean 继承过来的配置</li>
</ul>
</li>
<li>父 Bean 可以作为 Bean 实例, <strong>也可以作为配置模板</strong>.<ul>
<li><strong>若只想把父 Bean 作为模板, 可以设置 <code>&lt;bean&gt;</code> 的abstract 属性为 true</strong>, 这样 Spring 将不会实例化这个 Bean</li>
<li>也<strong>可以忽略父 Bean 的 class 属性</strong>, 让子 Bean 指定自己的类, 而共享相同的属性配置. 但此时 <strong>abstract 必须设为 true</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>(前置)依赖 Bean 配置</strong><ul>
<li><strong>Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean</strong>，前置依赖的 Bean 会在本 Bean 实例化之前创建好</li>
<li><strong>如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称</strong></li>
</ul>
</li>
</ul>
<blockquote><h3>继承 Bean 配置 示例</h3>
<p>xml文件 (新建的 beans-relation.xml)</p>
<pre class='brush:xml'>&lt;!-- 2, 抽象 bean : bean 的 abstract 属性为 true 的 bean , 这样的 bean 不能被 IOC 容器实例化, 只能用来 被继承 配置. --&gt;
&lt;bean id="parent" class="com.yafey.spring.helloworld.autowire.Address"
p:city="HangZhou" p:street="江干区" abstract="true"&gt;&lt;/bean&gt;
&lt;!-- 空行 --&gt;
&lt;!-- &lt;bean id="child" class="com.yafey.spring.helloworld.autowire.Address"
p:city="HangZhou" p:street="西湖区"/&gt; --&gt;
&lt;!-- 空行 --&gt;
&lt;!-- 1, bean 配置的继承 : 使用 bean 的 parent 属性指定继承哪个 bean 的配置.
        子 Bean 也可以覆盖从父 Bean 继承过来的配置 , 如 street 属性 --&gt;
&lt;bean id="child" parent="parent" p:city="Hangzhou" p:street="上城区"&gt;&lt;/bean&gt;
&lt;!-- 空行 --&gt;
&lt;!-- 2-2, 抽象 bean 作为 (父类)模板 bean , 可以不指定 class 属性 , 此时 abstract 属性是必须的.--&gt;
&lt;bean id="parent-abstract" p:city="HangZhou" p:street="江干区" abstract="true"&gt;&lt;/bean&gt;
&lt;!-- 如果 父类 bean 是抽象 bean , 且没有指定 class 属性, 子类必须指定 class , 可以继承(或覆盖)父类配置的属性. --&gt;
&lt;bean id="child-parent_abstract" p:street="江干区-钱江新城" parent="parent-abstract" class="com.yafey.spring.helloworld.autowire.Address"&gt;&lt;/bean&gt;
</pre><p>测试类 TestRelation.java 的 main 方法.</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.relation;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.yafey.spring.helloworld.autowire.Address;
public class TestRelation {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-relation.xml");
        // 2, 抽象 bean 不能 被实例化.
//      Address parent = (Address)ctx.getBean("parent");
//      System.out.println(parent);
//      
        Address child = (Address)ctx.getBean("child");
        System.out.println(child);
//      
        // 2-2, 抽象 模板 bean 的 属性的继承和覆盖. 父类不能被实例化.
        Address child_parent_abstract = (Address)ctx.getBean("child-parent_abstract");
        System.out.println(child_parent_abstract);
    }
}
// 输出:
//Address [city=Hangzhou, street=上城区]
//Address [city=HangZhou, street=江干区-钱江新城]
</pre></blockquote>
<p>&nbsp;</p>
<blockquote><h3>(前置)依赖 Bean 配置 示例</h3>
<p>xml文件</p>
<pre class='brush:xml'>&lt;!-- 3, (前置)依赖 bean (depends-on 属性) :要求在配置 bean 时, 必须有一个关联的 Car ! 换句话说 person 这个 bean 依赖于 Car 这个 bean. 
    前置依赖的 Bean 会在本 Bean 实例化之前创建好.--&gt;
&lt;bean id="car" class="com.yafey.spring.helloworld.Car" p:brand="Audi" p:price="300000"&gt;&lt;/bean&gt;
&lt;bean id="person" class="com.yafey.spring.helloworld.autowire.Person_autowire" 
    p:name="Tom" p:address-ref="child-parent_abstract" depends-on="car" p:car-ref="car"&gt;&lt;/bean&gt;
</pre><p>测试类 TestRelation.java 的 main 方法.</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.relation;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.yafey.spring.helloworld.autowire.Address;
public class TestRelation {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-relation.xml");
        // 3, 测试 依赖 bean (depends-on 属性) : 前置依赖的 Bean 会在本 Bean 实例化之前创建好.
        Person_autowire person = (Person_autowire)ctx.getBean("person");
        System.out.println(person);
    }
}
// 输出:
//Person_autowire [name=Tom, car=Car [company=null, brand=Audi, maxSpeed=0, price=300000.0], address=Address [city=HangZhou, street=江干区-钱江新城]]
</pre></blockquote>
<h2><span id="2.9.beans-workspace-environment">2.9, bean 的作用域：<em>singleton；prototype；Web 环境作用域</em></span></h2>
<ul>
<li>在 Spring 中, 可以在 <code>&lt;bean&gt;</code> 元素的 <strong><code>scope 属性</code></strong> 里设置 Bean 的作用域.<ul>
<li><code>singeton</code> :  <strong>默认值</strong> . <strong>容器初始化时创建 bean 实例</strong>. 在整个容器的生命周期内只创建这一个 bean . 单例的.(通过同一个bean 的 两个对象 == 查看.)</li>
<li><code>prototype</code> : 原型的 . <strong>容器创建时不创建 bean 的实例. 而在每次请求时都创建一个新的 bean 实例, 并返回.</strong>(通过无参构造函数观察) , <strong><em>(使用场景 : SSH整合时, Struts2 的 Action 的配置)</em></strong></li>
</ul>
</li>
<li><strong>默认情况下, Spring 只为每个在 IOC 容器里声明的 Bean 创建唯一一个实例, 整个 IOC 容器范围内都能共享该实例</strong>：所有后续的 getBean() 调用和 Bean 引用都将返回这个唯一的 Bean 实例.该作用域被称为 singleton, 它是所有 Bean 的默认作用域.</li>
</ul>
<p><img src="/blog_images/program/spring4.0/beans-scope.png" alt="Bean 的 scope 属性对应的作用域" title="Bean 的 scope 属性对应的作用域" /></p>
<blockquote><p>xml文件</p>
<pre class='brush:xml'>&lt;!-- 
    使用 bean 的 scope 属性来配置 bean 的作用域:
    - singleton :  默认值 . 容器初始化时创建 bean 实例. 在整个容器的生命周期内只创建这一个 bean . 单例的.(通过同一个bean 的 两个对象 == 查看.)
    - prototype : 原型的 . 容器创建时不创建 bean 的实例. 而在每次请求时都创建一个新的 bean 实例, 并返回.(通过无参构造函数观察)
 --&gt;
&lt;bean id="car" class="com.yafey.spring.helloworld.Car" scope="singleton"&gt;
    &lt;property name="brand" value="奥迪"/&gt;
    &lt;property name="company" value="一汽"/&gt;
&lt;/bean&gt;
</pre><p>测试类 TestScope.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-scope.xml");
    //
    System.out.println("...before getBean...");
    Car car = (Car)ctx.getBean("car");
    Car car2 = (Car)ctx.getBean("car");
    //
    System.out.println(car == car2);
}
// 输出:
// 当 scope 为 singleton 时 ,输出如下 , 容器初始化时创建 bean 实例
/*
Constructor...of Car 
...before getBean...
true
*/
// 当 scope 为 prototype 时 ,输出如下 , 容器创建时不创建 bean 的实例. 而在每次请求时都创建一个新的 bean 实例, 并返回
/*
...before getBean...
Constructor...of Car
Constructor...of Car
false
*/
</pre></blockquote>
<h2><span id="2.10.bean-use-outer-properties">2.10, 使用外部属性文件</span></h2>
<blockquote><p><strong>(因为 Opoopress 的原因 )下面的 <code>￥ 实际为 $</code> .</strong></p>
</blockquote>
<ul>
<li>在配置文件里配置 Bean 时, 有时需要在 Bean 的配置里混入<strong>系统部署的细节信息</strong>(<em>例如: 文件路径, 数据源配置信息等</em>). 而这些部署细节实际上需要和 Bean 配置相分离 .</li>
<li>Spring 提供了一个 <code>PropertyPlaceholderConfigurer</code> 的 <strong>BeanFactory 后置处理器</strong>, 这个处理器允许用户将 Bean 配置的部分内容外移到<strong>属性文件</strong>中. 可以在 Bean 配置文件里使用形式为 <strong><code>￥{var}</code></strong> 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量.</li>
<li>Spring 还允许在属性文件中使用 <strong><code>￥{propName}</code></strong>，以实现<strong>属性之间的相互引用</strong>。</li>
</ul>
<h3>2.10.1. 注册 PropertyPlaceholderConfigurer</h3>
<ul>
<li><strong>Spring 2.0 </strong>时, 需要手工配置 该 configurer , 指定 location , 指定 配置文件的路径.<pre class='brush:xml'>&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location" value="classpath:db.properties"&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre></li>
<li><strong>Spring 2.5 之后: 可通过 <code>&lt;context:property-placeholder&gt;</code> 元素简化:</strong><ul>
<li><code>&lt;beans&gt;</code> 中添加 <strong><code>context</code></strong> Schema 定义 (导入 context 命名空间)</li>
<li>在配置文件中加入如下配置:<pre class='brush:xml'>&lt;context:property-placeholder location="classpath:db.properties"/&gt;
</pre></li>
</ul>
</li>
</ul>
<blockquote><h3>使用外部属性文件 示例</h3>
<p>需要导入 以下 两个 jar 包.</p>
<ul>
<li>c3p0-0.9.1.2.jar</li>
<li>commons-logging-1.1.1.jar</li>
</ul>
<p>xml文件  (<strong>(因为 Opoopress 的原因 )下面的 <code>￥ 实际为 $</code> .</strong> )</p>
<pre class='brush:xml'>&lt;!-- 1, 导入属性文件 --&gt;
&lt;context:property-placeholder location="classpath:db.properties"/&gt;
&lt;!-- 2, 使用外部化属性文件的属性 --&gt;
&lt;bean id="dataSource_properties" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
    &lt;property name="user" value="￥{user}"/&gt;
    &lt;property name="password" value="￥{password}"/&gt;
    &lt;property name="driverClass" value="￥{driverClass}"/&gt;
    &lt;property name="jdbcUrl" value="￥{jdbcUrl}"/&gt;
&lt;/bean&gt;
</pre><p>db.properties</p>
<pre class='brush:text'>user=root
password=root
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql:///test
</pre><p>测试类 TestProperties.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) throws SQLException {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-properties.xml");

    DataSource dataSource = (DataSource) ctx.getBean("dataSource_properties");
    System.out.println(dataSource.getConnection());
}
// 输出:
//com.mchange.v2.c3p0.impl.NewProxyConnection@5d3908f1
</pre></blockquote>
<h2><span id="2.11.spEL">2.11, Spring表达式语言：SpEL</span></h2>
<blockquote><p>SpEL 的语法<strong>更详细版</strong> 参考 <a href="http://jinnianshilongnian.iteye.com/blog/1418309" target="_blank" title="外链-iteye">(开涛的博客)【第五章】Spring表达式语言 之 5.3 SpEL语法 ——跟我学spring3</a></p>
<ul>
<li>更简便的测试 SpEL 的写法:<pre class='brush:java'>ExpressionParser parser = new SpelExpressionParser();  
String expression1 = "2&gt;1 and (!true or !false)";  
boolean result1 = parser.parseExpression(expression1).getValue(boolean.class);
Assert.assertEquals(true, result1); 
</pre></li>
</ul>
</blockquote>
<ul>
<li><strong>Spring 表达式语言（简称SpEL）</strong>：是一个<strong>支持运行时查询和操作对象图的强大的表达式语言。</strong></li>
<li><strong>语法类似于 EL：SpEL 使用 <code>#{…}</code> 作为定界符，所有在大框号中的字符都将被认为是 SpEL</strong>.</li>
<li><strong>SpEL 为 bean 的属性进行 动态赋值 提供了便利</strong></li>
<li>通过 SpEL 可以实现：<ul>
<li>通过 bean 的 id 对 bean 进行引用</li>
<li>调用方法以及引用对象中的属性</li>
<li>计算表达式的值</li>
<li>正则表达式的匹配</li>
</ul>
</li>
</ul>
<h3>2.11.1. spEL 具体语法</h3>
<ol>
<li><strong>字面量</strong> (作为某个 bean 的属性)(<strong>如果仅是使用一些字面值的话, 使用 spEL 的意义不大</strong>).
字面量的表示：<ul>
<li>整数：<code>&lt;property name="count" value="#{5}"/&gt;</code></li>
<li>小数：<code>&lt;property name="frequency" value="#{89.7}"/&gt;</code></li>
<li>科学计数法：<code>&lt;property name="capacity" value="#{1e4}"/&gt;</code></li>
<li>String可以<strong>使用单引号或者双引号作为字符串的定界符号</strong>：<code>&lt;property name=“name” value="#{'Chuck'}"/&gt;</code> 或 <code>&lt;property name='name' value='#{"Chuck"}'/&gt;</code></li>
<li>Boolean：<code>&lt;property name="enabled" value="#{false}"/&gt;</code></li>
</ul>
</li>
<li><strong>SpEL：引用 Bean、属性和方法 —— <em>(语法: <code>value="#{...}"</code>)</em></strong><ul>
<li>引用其他对象：<pre class='brush:xml'>&lt;!-- 通过 value 属性 和 spEL 配置 Bean 之间的应用关系  --&gt;
&lt;property name="prefix" value="#{prefixGenerator}"&gt;&lt;/property&gt;
</pre></li>
<li><strong>引用其他对象的属性(普通的配置方式做不到)</strong><pre class='brush:xml'>&lt;!-- 通过 value 属性 和 spEL 配置 suffix 属性值 为另一个 Bean 的 suffix 属性值  --&gt;
&lt;property name="suffix" value="#{sequenceGenerator2.suffix}"&gt;&lt;/property&gt;
</pre></li>
<li>调用其他方法，还可以链式操作<pre class='brush:xml'>&lt;!-- 通过 value 属性 和 spEL 配置 suffix 属性值 为另一个 Bean 的方法的返回值 --&gt;
&lt;property name="suffix" value="#{sequenceGenerator2.toString()}"&gt;&lt;/property&gt;
&lt;!-- 方法的链式 --&gt;
&lt;property name="suffix" value="#{sequenceGenerator2.toString().toUpperCase()}"&gt;&lt;/property&gt;
</pre></li>
<li><strong>调用静态方法或静态属性：</strong>通过 <strong><code>T(type)</code></strong> 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性：
<br /><em>使用“T(Type)”来表示java.lang.Class实例，“Type”必须是<strong>类全限定名，“java.lang”包除外，即该包下的类可以不指定包名</strong>；使用类类型表达式还可以进行访问类静态方法及类静态字段。</em><pre class='brush:xml'>&lt;property name="initValue" value="#{T(java.lang.Math).PI * 80}"&gt;&lt;/property&gt;
</pre></li>
</ul>
</li>
<li><strong>SpEL支持的运算符号</strong><ul>
<li>算数运算符：<code>+, -, *, /, %, ^(幂运算)</code>：<pre class='brush:xml'>&lt;property name="adjustedAmount" value="#{counter.total + 42}"/&gt;
&lt;property name="adjustedAmount" value="#{counter.total - 20}"/&gt;
&lt;property name="circumference" value="#{2 * T(java.lang.Math).PI * circle.radius}"/&gt;
&lt;property name="average" value="#{counter.total / counter.count}"/&gt;
&lt;property name="remainder" value="#{counter.total % counter.count}"/&gt;
&lt;property name="area" value="#{T(java.lang.Math).PI * circle.radius ^ 2}"/&gt;
</pre></li>
<li><code>加号还可以用作字符串连接</code>：<pre class='brush:xml'>&lt;constructor-arg value="#{performer.firstName + ' ' + performer.lastName}"/&gt;
</pre></li>
<li>比较运算符： <code>&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge</code><pre class='brush:xml'>&lt;property name="equal" value="#{counter.total == 100}"/&gt;
&lt;property name="hasCapacity" value="#{counter.total le 10000}"/&gt;
</pre></li>
<li>逻辑运算符号： <code>and, or, not, |</code><pre class='brush:xml'>&lt;property name="largeCircle" value="#{shape.kind == 'circle' and shape.perimeter gt 10000}"/&gt;
&lt;property name="ourOfStock" value="#{!product.available}"/&gt;
&lt;property name="ourOfStock" value="#{not product.available}"/&gt;
</pre></li>
<li>if-else 运算符(三目运算)：<code>表达式1?表达式2:表达式3</code>(ternary,三目运算)<pre class='brush:xml'>&lt;constructor-arg value="#{songSelector.selectSong == 'Jingle Bells' ? 'piano' : 'Jingle Bells'}"/&gt;
</pre></li>
<li>if-else 的变体(三目运算的简化) : <code>表达式1?:表达式2</code>(Elvis,从Groovy语言引入用于简化三目运算符的)<ul>
<li>当 <strong>表达式1 为非 null 时则返回 表达式1</strong>，当 表达式1 为 null 时则返回 表达式2，<strong>简化了三目运算符方式</strong>.</li>
<li>如 <code>null?:false</code> 将返回 false，而 <code>true?:false</code> 将返回 true；<pre class='brush:xml'>&lt;constructor-arg value="#{kenny.song ?: 'GreenSleeves'}"/&gt;
</pre></li>
</ul>
</li>
<li>正则表达式：<code>matches</code><pre class='brush:xml'>&lt;constructor-arg value="#{admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}'}"/&gt;
</pre></li>
</ul>
</li>
</ol>
<blockquote><h3>spEL 具体语法 使用示例</h3>
<p>定义 Car_spel.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.spel;
public class Car_spel {
    public Car_spel() {
        System.out.println("Car_spel Construtor...");
    }
    private String  brand;
    private double price;
    private double tyrePerimeter;  // 轮胎的周长
    // setter... / getter... / toString ...
}
</pre><p>定义 Person_spel.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.spel;
public class Person_spel {
    private String name;
    private Car_spel car_spel;
    /**
     *  引用 Address bean 的 city 属性
     */
    private String city;
    /**
     * 根据 car 的 price 确定 info : &lt;br/&gt;
     * car 的 price &gt;= 300000 : 金领 &lt;br/&gt;
     * 否则 为 白领.
     */
    private String info;
    // setter... / getter... / toString()...
    public Person_spel() {
        System.out.println("Person_spel Constructor ...");
    }
}
</pre><p>xml中的配置</p>
<pre class='brush:xml'>&lt;bean id="address" class="com.yafey.spring.helloworld.autowire.Address"&gt;
    &lt;!-- 使用 spel 为属性赋一个字面值-String --&gt;
    &lt;property name="city" value="#{'杭州'}"&gt;&lt;/property&gt;
    &lt;property name="street" value="江干区"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="car_spel" class="com.yafey.spring.helloworld.spel.Car_spel"&gt;
    &lt;property name="brand" value="奥迪"&gt;&lt;/property&gt;
    &lt;property name="price" value="500000"&gt;&lt;/property&gt;
    &lt;!-- 使用 spEL 引用类的静态属性 --&gt;
    &lt;property name="tyrePerimeter" value="#{T(java.lang.Math).PI * 80}"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="person_spel" class="com.yafey.spring.helloworld.spel.Person_spel"&gt;
    &lt;!-- 使用 spEL 来引用其他的 Bean --&gt;
    &lt;property name="car_spel" value="#{car_spel}"&gt;&lt;/property&gt;
    &lt;!-- 使用 spEL 来引用其他的 Bean 的属性 --&gt;
    &lt;property name="city" value="#{address.city}"&gt;&lt;/property&gt;
    &lt;!-- 使用 spEL 中的 运算符 , 动态赋值 --&gt;
    &lt;property name="info" value="#{car_spel.price &gt;300000 ? '金领' : '白领'}"&gt;&lt;/property&gt;
    &lt;property name="name" value="Tom"&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><p>测试类 TestSpEL.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-spel.xml");
    //
    Address address = (Address)ctx.getBean("address");
    System.out.println(address);
    //
    Car_spel car_spel = (Car_spel)ctx.getBean("car_spel");
    System.out.println(car_spel);
    //
    Person_spel person_spel = (Person_spel)ctx.getBean("person_spel");
    System.out.println(person_spel);
}
// 输出:
//Address [city=杭州, street=江干区]
//Car_spel [brand=奥迪, price=500000.0, tyrePerimeter=251.32741228718345]
//Person [name=Tom, car_spel=Car_spel [brand=奥迪, price=500000.0, tyrePerimeter=251.32741228718345], city=杭州, info=金领]
</pre></blockquote>
<h2><span id="2.12.bean-life-in-IOC">2.12, IOC 容器中 Bean 的生命周期</span></h2>
<h3>2.12.1. IOC 容器中 Bean 的生命周期方法</h3>
<ul>
<li><strong>Spring IOC 容器可以管理 Bean 的生命周期</strong>, Spring 允许在 Bean 生命周期的特定点执行定制的任务.</li>
<li><strong>Spring IOC 容器对 Bean 的生命周期进行管理的过程</strong>:<ol>
<li>通过构造器或工厂方法创建 Bean 实例</li>
<li>为 Bean 的属性设置值和对其他 Bean 的引用</li>
<li><strong>调用 Bean 的初始化方法</strong></li>
<li>Bean 可以使用了</li>
<li><strong>当容器关闭时, 调用 Bean 的销毁方法</strong></li>
</ol>
</li>
<li>在 Bean 的声明里设置 <strong>init-method</strong> 和 <strong>destroy-method</strong> 属性, 为 Bean 指定初始化和销毁方法.</li>
</ul>
<h3>2.12.2. 创建 Bean 后置处理器</h3>
<ul>
<li><strong>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.</strong></li>
<li><strong>Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理</strong>, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性.</li>
<li>对Bean 后置处理器而言, 需要<strong>实现 <code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口</strong>. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:<pre class='brush:java'>Object postProcessBeforeInitialization(Object bean, String beanName) // init-method 之前被调用
Object postProcessAfterInitialization(Object bean, String beanName) // init-method 之后被调用
</pre></li>
<li>Spring IOC 容器对 <strong>添加 Bean 后置处理器后 Bean 的生命周期</strong> 进行管理的过程: (<strong>对Bean 的生命周期的管理更加细致.</strong>)<ol>
<li>通过构造器或工厂方法创建 Bean 实例</li>
<li>为 Bean 的属性设置值和对其他 Bean 的引用</li>
<li><strong>将 Bean 实例传递给 Bean 后置处理器的 <code>postProcessBeforeInitialization</code> 方法</strong></li>
<li>调用 Bean 的初始化方法</li>
<li><strong>将 Bean 实例传递给 Bean 后置处理器的 <code>postProcessAfterInitialization方法</code></strong></li>
<li>Bean 可以使用了</li>
<li>当容器关闭时, 调用 Bean 的销毁方法</li>
</ol>
</li>
</ul>
<blockquote><h3>IOC 容器中 Bean 的生命周期(结合 bean后置处理器) 示例</h3>
<p>定义 Car_cycle.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.cycle;
public class Car_cycle {
    public Car_cycle() {
        System.out.println("【1.创建 Bean 实例】Car_cycle Construtor...");
    }
    private String  brand;
    public void init(){
        System.out.println("【4.调用 Bean 的初始化方法】Car_cycle init...");
    }
    public void destroy(){
        System.out.println("【7.当容器关闭时, 调用 Bean 的销毁方法】Car_cycle destroy...");
    }
    public String getBrand() {
        return brand;
    }
    public void setBrand(String brand) {
        System.out.println("【2.为 Bean 的属性设置值和对其他 Bean 的引用】Car_cycle setBrand...");
        this.brand = brand;
    }
    @Override
    public String toString() {
        System.out.println("【6.Bean 可以使用了】Car_cycle toString()...模拟使用 bean");
        return "Car_cycle [brand=" + brand + "]";
    }
}
</pre><p>定义 MyBeanPostProcessor.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.cycle;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println("【3.将 Bean 实例传递给 Bean 后置处理器的 before 方法】postProcessBeforeInitialization:【"+beanName + "】," + bean);
        return bean;  //需要把 bean 返回. 可以对 bean 进行一些操作 , 甚至 可以 返回一个新的 bean 对象
    }
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println("【5.将 Bean 实例传递给 Bean 后置处理器的 after 方法】postProcessBeforeInitialization:【"+beanName + "】," + bean);
        if (bean instanceof Car_cycle){  // 将原始的 bean 修改为一个新的 bean 对象.
            Car_cycle modify = new Car_cycle();
            modify.setBrand("奇瑞QQ");
            bean = modify;
        }
        return bean;
    }
}
</pre><p>xml中的配置</p>
<pre class='brush:xml'>&lt;bean id="car_cycle" class="com.yafey.spring.helloworld.cycle.Car_cycle"
    init-method="init" destroy-method="destroy"&gt;
    &lt;property name="brand" value="奥迪" /&gt;
&lt;/bean&gt;
&lt;!-- 
    实现 BeanPostProcessor 接口, 并具体提供 
    Object postProcessBeforeInitialization(Object bean, String beanName) : init-method 之前被调用
    Object postProcessAfterInitialization(Object bean, String beanName) : init-method 之后被调用
    的实现
    bean : bean 实例 本身
    beanName : IOC 容器配置的 bean 的 id.
    返回值 : 是实际返回给用户的那个 Bean , 注意 : 可以在以上的两个方法中修改返回的 bean , 甚至返回一个新的 bean.
 --&gt;
&lt;!-- 配置 bean 的后置处理器 ： 不需要配置 id ， IOC 容器自动识别是一个 BeanPostProcessor bean后置处理器 --&gt;
&lt;bean class="com.yafey.spring.helloworld.cycle.MyBeanPostProcessor"/&gt;
</pre><p>测试类 TestCycle.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) {
    ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans-cycle.xml");
    //
    Car_cycle car_cycle = (Car_cycle)ctx.getBean("car_cycle");
    System.out.println(car_cycle);
    // 关闭 IOC 容器. 声明时需要使用 具体实现类.
    ctx.close();
}
// 输出:
//【1.创建 Bean 实例】Car_cycle Construtor...
//【2.为 Bean 的属性设置值和对其他 Bean 的引用】Car_cycle setBrand...
//【3.将 Bean 实例传递给 Bean 后置处理器的 before 方法】postProcessBeforeInitialization:【car_cycle】,Car_cycle [brand=奥迪]
//【4.调用 Bean 的初始化方法】Car_cycle init...
//【5.将 Bean 实例传递给 Bean 后置处理器的 after 方法】postProcessBeforeInitialization:【car_cycle】,Car_cycle [brand=奥迪]
//【6.Bean 可以使用了】Car_cycle toString()...模拟使用 bean
//Car_cycle [brand=奇瑞QQ]  , 【经过后置处理器返回的新对象.】
//【7.当容器关闭时, 调用 Bean 的销毁方法】Car_cycle destroy...
</pre></blockquote>
<h2><span id="2.13.bean-config-static-factory-new-instance">2.13, Bean 的配置方式：通过工厂方法（静态工厂方法 &amp; 实例工厂方法）</span></h2>
<h3>2.13.1. 通过调用<code>静态工厂方法</code>创建 Bean</h3>
<ul>
<li>调用 <strong>静态工厂方法</strong> 创建 Bean 是将 <strong>对象创建的过程封装到静态方法中</strong>. 当客户端需要对象时, 只需要简单地调用静态方法, 而不用关心创建对象的细节.</li>
<li>要声明通过静态方法创建的 Bean, 需要在 Bean 的 <strong>class 属性</strong>里指定拥有该工厂的方法的类, 同时在 <strong>factory-method 属性</strong>里指定工厂方法的名称. 最后, 使用 <code>&lt;constrctor-arg&gt;</code> 元素为该方法传递方法参数.</li>
</ul>
<blockquote><p>定义 StaticCarFactory.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.factory;
import java.util.*;
import com.yafey.spring.helloworld.Car;
/**
 * 静态工厂方法: 直接调用某一个类的静态方法就可以返回 Bean 的实例
 */
public class StaticCarFactory {
    private static Map&lt;String, Car&gt; cars = new HashMap&lt;String, Car&gt;();
    static{
        cars.put("audi", new Car("一汽--静态工厂方法", "奥迪", 300000));
        cars.put("santana", new Car("大众--静态工厂方法", "桑塔纳", 200000));
    }
    //静态工厂方法
    public static Car getCar(String name){
        return cars.get(name);
    }
}
</pre><p>xml中的配置</p>
<pre class='brush:xml'>&lt;!-- 
    1, 通过静态工厂方法来配置 bean .
    注意 : 不是配置静态工厂方法实例 , 而是配置 bean 实例.
    class 属性 : 指向静态工厂方法的全类名.
    factory-method  : 指向静态工厂方法的名字.
    &lt;constructor-arg&gt; : 如果工厂方法需要传入参数 , 则使用 &lt;constructor-arg&gt;子元素 来配置参数.
--&gt;
&lt;bean id="staticCar" class="com.yafey.spring.helloworld.factory.StaticCarFactory"
    factory-method="getCar"&gt;
    &lt;constructor-arg value="audi"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre><p>测试类 TestStaticFactory.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) throws SQLException {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-factory.xml");
    // 1. 通过静态工厂方法来配置 bean .
    Car staticCar = (Car) ctx.getBean("staticCar");
    System.out.println(staticCar);
}
// 输出:
//Car [company=一汽--静态工厂方法, brand=奥迪, maxSpeed=300000, price=0.0]
</pre></blockquote>
<h3>2.13.2. 通过调用<code>实例工厂方法</code>创建 Bean</h3>
<ul>
<li><strong>实例工厂方法: 将对象的创建过程封装到另外一个对象实例的方法里. </strong>当客户端需要请求对象时, 只需要简单的调用该实例方法而不需要关心对象的创建细节.</li>
<li>要声明通过实例工厂方法创建的 Bean<ul>
<li>在 bean 的 <strong>factory-bean 属性</strong>里指定拥有该工厂方法的 Bean</li>
<li>在 <strong>factory-method 属性</strong>里指定该工厂方法的名称</li>
<li>使用 <strong>construtor-arg 元素</strong>为工厂方法传递方法参数</li>
</ul>
</li>
</ul>
<blockquote><p>定义 InstanceCarFactory.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.factory;
import java.util.*;
import com.yafey.spring.helloworld.Car;
/**
 * 实例工厂方法: 实例工厂 的(非静态)方法. 即先需要创建工厂本身, 再调用工厂的(非静态)实例方法.
 */
public class InstanceCarFactory {
    private static Map&lt;String, Car&gt; cars = null;
    public InstanceCarFactory(){
        cars = new HashMap&lt;String, Car&gt;();
        cars.put("audi", new Car("一汽--实例工厂方法", "奥迪", 300000));
        cars.put("santana", new Car("大众--实例工厂方法", "桑塔纳", 200000));
    }
    public Car getCar(String name){
        return cars.get(name);
    }
}
</pre><p>xml中的配置</p>
<pre class='brush:xml'>&lt;!-- 2-1, 配置工厂的实例 --&gt;
&lt;bean id="carFactory" class="com.yafey.spring.helloworld.factory.InstanceCarFactory"/&gt;
&lt;!-- 
    2-2, 通过 实例工厂方法 来配置bean 
    factory-bean 属性 : 指向实例工厂方法的 bean
    factory-method  : 指向静态工厂方法的名字.
    &lt;constructor-arg&gt; : 如果工厂方法需要传入参数 , 则使用 &lt;constructor-arg&gt;子元素 来配置参数.
--&gt;
&lt;bean id="instanceCar" factory-bean="carFactory" factory-method="getCar"&gt;
    &lt;constructor-arg value="santana"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre><p>测试类 TestStaticFactory.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) throws SQLException {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-factory.xml");
    // 2, 通过 实例工厂方法 来配置bean 
    Car instanceCar = (Car) ctx.getBean("instanceCar");
    System.out.println(instanceCar);
}
// 输出:
//Car [company=大众--实例工厂方法, brand=桑塔纳, maxSpeed=200000, price=0.0]
</pre></blockquote>
<h2><span id="2.14.bean-config-factory-bean">2.14.Bean 的配置方式：实现 FactoryBean 接口在 Spring IOC 容器中配置 Bean </span></h2>
<blockquote><p>(配置 bean 的时候需要使用到 IOC 容器中的 其他 Bean&mdash;使用 Spring 的 FactoryBean 最合适).</p>
</blockquote>
<ul>
<li>Spring 中有两种类型的 Bean, 一种是普通Bean, 另一种是 <strong><code>FactoryBean</code></strong>.</li>
<li><strong>FactoryBean</strong> 跟普通Bean不同, 其返回的对象不是指定类的一个实例, <strong>其返回的是该 FactoryBean 的 getObject() 方法所返回的对象</strong></li>
</ul>
<pre class='brush:java'>public interface FactoryBean {
    // FactoryBean 返回的实例
    Object getObject() throws Exception;
    // FactoryBean 返回的类型
    Class getObjectType();
    // FactoryBean 返回的实例 是否为单例
    boolean isSingleton();
}
</pre><blockquote><p>定义 CarFactoryBean.java</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.factorybean;
import org.springframework.beans.factory.FactoryBean;
import com.yafey.spring.helloworld.Car;
//自定义的 FactoryBean 需要实现  org.springframework.beans.factory.FactoryBean 接口
public class CarFactoryBean implements FactoryBean&lt;Car&gt; {
    private String brand;
    public void setBrand(String brand) {
        this.brand = brand;
    }
    /**
     * 返回 bean 的对象
     */
    @Override
    public Car getObject() throws Exception {
        // TODO Auto-generated method stub
        return new Car("一汽--Spring 的 FactoryBean", brand, 500000);
    }
    /**
     * 返回 bnean 的类型
     */
    @Override
    public Class&lt;?&gt; getObjectType() {
        return Car.class;
    }
    /**
     * 返回是否单例的
     */
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</pre><p>xml中的配置</p>
<pre class='brush:xml'>&lt;!-- 
    通过 FactoryBean 来配置 Bean 的实例.
    class : 指向 FactoryBean 的全类名.
    property : 配置 FactoryBean 的属性.

    但实际返回的实例 却是 FactoryBean 的 getObject() 方法返回的实例 !
 --&gt;
&lt;bean id="car" class="com.yafey.spring.helloworld.factorybean.CarFactoryBean"&gt;
    &lt;property name="brand" value="BMW"&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><p>测试类 TestStaticFactory.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) throws SQLException {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-spring-factorybean.xml");
    Car car = (Car) ctx.getBean("car");
    System.out.println(car);
}
// 输出:
//Car [company=一汽--Spring 的 FactoryBean, brand=BMW, maxSpeed=500000, price=0.0]
</pre></blockquote>
<h2><span id="2.15.spring-annotation-scan">2.15, Bean 的配置形式：基于注解的方式（基于注解配置 Bean；基于注解来装配 Bean 的属性）</span></h2>
<h3><span id="2.15.1.spring-annotation-scan-component">2.15.1. 在 classpath 中扫描组件 (<em>基于注解配置 Bean</em>)</span></h3>
<ul>
<li><strong>组件扫描(component scanning)</strong>:  Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件.</li>
<li><strong>特定组件</strong>包括: <em>(目前注解可以混用,IOC容器无法知道一个类到底是哪个组件.)</em><ul>
<li><code>@Component</code>: 基本注解, 标识了一个受 Spring 管理的组件</li>
<li><code>@Respository</code>: 标识持久层组件</li>
<li><code>@Service</code>: 标识服务层(业务层)组件</li>
<li><code>@Controller</code>: 标识表现层组件</li>
</ul>
</li>
<li>对于扫描到的组件, <strong>Spring 有默认的命名策略: 使用非限定类名, 第一个字母小写.</strong> <em>(例如:<code>类名:UserService</code>, 默认bean 的id 为 <code>userService</code>)</em>. <strong>也可以在注解中通过 value 属性值标识组件的名称</strong>.<em>(例如:<code>类名:UserServiceImpl</code>, 可以通过 value 属性指定为 <code>userService</code>,当然这是可选的潜规则.)</em>.</li>
</ul>
<p><strong>当在组件类上使用了特定的注解之后</strong>,</p>
<ul>
<li>还需要在 <strong>Spring 的配置文件</strong>中声明 <code>&lt;context:component-scan&gt;</code> ：<ul>
<li><strong><code>base-package 属性</code></strong> : _<em>指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类. </em>_</li>
<li><strong>当需要扫描多个包时, 可以使用逗号分隔.</strong></li>
<li>如果仅希望扫描<strong>(特定包下的)特定的类</strong>而<strong>非基包下的所有类</strong>，可使用 <strong><code>resource-pattern 属性</code></strong> 过滤特定的类，示例：<pre class='brush:xml'>&lt;context:component-scan base-package="com.yafey.beans"
resources-pattern="autowire/*.class"    /&gt;
</pre></li>
<li><strong><code>&lt;context:include-filter&gt; 子节点</code> 表示要包含的目标类 , 该节点必须配置 <code>&lt;context:component-scan&gt;</code>节点的 <code>use-default-filters="false"</code>(默认为true,启用默认的过滤器) 使用.</strong></li>
<li><strong><code>&lt;context:exclude-filter&gt; 子节点</code> 表示要排除在外的目标类</strong></li>
<li><code>&lt;context:component-scan&gt;</code>下可以拥有若干个 <code>&lt;context:include-filter&gt;</code> 和<code>&lt;context:exclude-filter&gt;</code> 子节点<ul>
<li><code>&lt;context:include-filter&gt;</code> 和 <code>&lt;context:exclude-filter&gt;</code> 子节点支持多种类型的过滤表达式：
<img src="/blog_images/program/spring4.0/context-scan-include_exclude-filter.png" alt="&lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 子节点支持多种类型的过滤表达式" title="&lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 子节点支持多种类型的过滤表达式" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote><h3>基于注解配置 Bean 简单示例</h3>
<p>定义 TestObject.java , 使用 <code>@Component</code> 组件注解</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.annotation;
import org.springframework.stereotype.Component;
@Component
public class TestObject {
}
</pre><p>定义 UserService.java , 使用 <code>@Service</code> 业务层组件注解</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.annotation.service;
import org.springframework.stereotype.Service;
@Service
public class UserService {
    public void add() {
        System.out.println("UserService add...");
    }
}
</pre><p>定义 UserRepositoryImpl.java , 使用 <code>@Repository</code> 持久层组件注解</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.annotation.repository.impl;
import org.springframework.stereotype.Repository;
import com.yafey.spring.helloworld.annotation.repository.UserRepository;
@Repository("userRepository")
public class UserRepositoryImpl implements UserRepository {
    @Override
    public void save() {
        System.out.println("UserRepositoryImpl save...");
    }
}
</pre><p>定义 UserController.java , 使用 <code>@Controller</code> 表现层组件注解</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.annotation.controller;
import org.springframework.stereotype.Controller;
@Controller
public class UserController {
    public void execute() {
        System.out.println("UserController execute...");
    }
}
</pre><p>xml中的配置 , 注意 导入 context 的 命名空间</p>
<pre class='brush:xml'>&lt;!-- 指定 Spring IOC 容器扫描的包 --&gt;
&lt;context:component-scan base-package="com.yafey.spring.helloworld.annotation"&gt;&lt;/context:component-scan&gt;
</pre><p>测试类 TestAnnotation.java 的 main 方法.</p>
<pre class='brush:java'>public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-annotation.xml");
    // 测试 基本组件
    TestObject to = (TestObject) ctx.getBean("testObject");
    System.out.println(to);
    // 测试 持久层组件
    UserRepository userRepository = (UserRepository) ctx.getBean("userRepository");
    System.out.println(userRepository);
    // 测试 业务层组件
    UserService userService = (UserService) ctx.getBean("userService");
    System.out.println(userService);
    // 测试 表现层组件
    UserController userController = (UserController) ctx.getBean("userController");
    System.out.println(userController);
}
// 输出:
//com.yafey.spring.helloworld.annotation.TestObject@66886381
//com.yafey.spring.helloworld.annotation.repository.impl.UserRepositoryImpl@43cdebe
//com.yafey.spring.helloworld.annotation.service.UserService@38438e1e
//com.yafey.spring.helloworld.annotation.controller.UserController@5b27706d
</pre></blockquote>
<p>&nbsp;</p>
<blockquote><h3>基于注解配置 Bean 扫描<strong>(特定包下的)特定的类</strong>而<strong>非基包下的所有类</strong></h3>
<p>使用 <strong><code>resource-pattern 属性</code></strong> 过滤特定的类 示例
<img src="/blog_images/program/spring4.0/context-scan-resource-pattern.gif" alt="扫描(特定包下的)特定的类而非基包下的所有类 , resource-pattern 属性 示例" title="扫描(特定包下的)特定的类而非基包下的所有类 , resource-pattern 属性 示例" /></p>
</blockquote>
<p>&nbsp;</p>
<blockquote><h3>基于注解配置 Bean &ndash; 根据配置进行过滤 示例</h3>
<p>测试类 TestAnnotation.java 的 main 方法 不变 , 输出结果根据 配置的不同 , 不符合过滤条件的 bean 会找不到.</p>
<pre class='brush:xml'>&lt;!--
    use-default-filters : 默认的过滤器 , include-filter 生效的话, 必须将其设置为 false.
    &lt;context:include-filter&gt; 子节点 表示要包含的目标类
    &lt;context:exclude-filter&gt; 子节点 表示要排除在外的目标类 --&gt;
&lt;context:component-scan base-package="com.yafey.spring.helloworld.annotation"
    use-default-filters="false"&gt;
    &lt;!-- annotation,基于注解过滤 ; assignable, 基于父类或接口过滤 --&gt;
    &lt;!-- &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; --&gt;
    &lt;context:include-filter type="assignable" expression="com.yafey.spring.helloworld.annotation.repository.UserRepository"/&gt;
&lt;/context:component-scan&gt;
</pre></blockquote>
<h3><span id="2.15.2.spring-annotation-scan-resource">2.15.2. 组件属性装配 (<em>基于注解来装配 Bean 的属性</em>)</span></h3>
<p><code>&lt;context:component-scan&gt;</code> 元素还会自动<code>注册 AutowiredAnnotationBeanPostProcessor 实例</code>, 该实例可以自动装配具有 <code>@Autowired</code> 和<code>@Resource</code> 、<code>@Inject</code>注解的属性.</p>
<ul>
<li><strong>使用 @Autowired 自动装配 Bean</strong><ul>
<li>@Autowired 注解自动装配具有 <strong>类型兼容</strong> 的单个 Bean属性<ul>
<li><strong>构造器 / 普通字段(即使是非 public) / 一切具有参数的方法 都可以应用@Authwired 注解</strong></li>
<li><strong>默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常</strong>.<ul>
<li><strong>若某一属性允许不被设置, 可以设置 @Authwired 注解的 required 属性为 false</strong> <code>@Authwired(required=false)</code></li>
</ul>
</li>
<li>@Authwired 注解也可以应用在 <strong>数组类型 </strong>的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配.</li>
<li>@Authwired 注解也可以应用在 <strong>集合属性</strong> 上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean.<ul>
<li>@Authwired 注解用在 <strong>java.util.Map</strong> 上时, 若该 Map 的键值为 String, 那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值</li>
</ul>
</li>
</ul>
</li>
<li>默认情况下, 当 IOC 容器里存在<strong>多个类型兼容的 Bean 时</strong>, 通过类型的自动装配将无法工作.<ol>
<li>此时可以在 <strong><code>@Qualifier</code></strong> 注解里提供 Bean 的名称. <strong>Spring 允许对方法的入参标注 @Qualifiter 已指定注入 Bean 的名称</strong>. 示例:<ul>
<li>在方法前. <code>@Qualifier("userRepositoryImpl")</code></li>
<li>在方法的参数之前.</li>
</ul>
</li>
<li>配置 bean 的时候 , 声明 bean 的名字 和 属性名一致.</li>
</ol>
</li>
</ul>
</li>
<li><strong>使用 @Resource 或 @Inject 自动装配 Bean</strong><ul>
<li>Spring 还支持 @Resource 和 @Inject 注解，<strong>这两个注解和 @Autowired 注解的功用类似</strong></li>
<li><strong>@Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称</strong></li>
<li>@Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性</li>
<li><strong>建议使用 @Autowired 注解</strong></li>
</ul>
</li>
</ul>
<blockquote><h3>基于注解来装配 Bean 的属性 使用示例</h3>
<pre class='brush:java'>@Service
public class UserService {
    private UserRepository userRepository;
    @Autowired
    @Qualifier("userRepository")
    public void setUserRepository(/*@Qualifier("userRepository")*/UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    public void add() {
        System.out.println("UserService add...");
    }
}
</pre></blockquote>
<h2><span id="2.16.new-feature-in-Spring-4.x">2.16, Spring 4.x 新特性：泛型依赖注入</span></h2>
<p>Spring 4.x 中可以<strong>为子类注入子类对应的泛型类型的成员变量的引用</strong>
<img src="/blog_images/program/spring4.0/spring4-new-feature-generic-DI.png" alt="Spring 4.x 新特性：泛型依赖注入UML图" title="Spring 4.x 新特性：泛型依赖注入UML图" /></p>
<ul>
<li><strong>两个(带泛型的)基类</strong>:<ul>
<li><strong>BaseService</strong> 中定义了一些常用方法(<em>如:save,delete,query等</em>) .</li>
<li>BaseService 持有 <strong>BaseRepository</strong>(操作资源具体的方法) 的引用, 以便调用其定义的方法.</li>
</ul>
</li>
<li>两个基类可能有很多的实现类, <strong>在继承的时候需要提供泛型<code>&lt;T&gt;</code>的实例</strong>.<ul>
<li><em>如 : UserService子类 在继承的时候, 泛型<code>&lt;T&gt;</code>假设就叫 User . UserRepository子类 的泛型<code>&lt;T&gt;</code>假设也叫 User.</em> <strong>这时候,UserService 和 UserRepository 会自动的建立引用关系, 这就是 泛型依赖注入.</strong></li>
</ul>
</li>
</ul>
<blockquote><h3>Spring 4.x 新特性：泛型依赖注入 具体实例代码</h3>
<p>新建 BaseRepository.java 基类</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.generic.di;
public class BaseRepository&lt;T&gt; {
}
</pre><p>新建 BaseService.java 基类</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.generic.di;
import org.springframework.beans.factory.annotation.Autowired;
public class BaseService&lt;T&gt; {
    @Autowired //在属性而不是类上添加注解 , 这样该注解可以被子类继承.
    protected BaseRepository&lt;T&gt; baseRepository;
    public void add(){
        System.out.println("add...");
        System.out.println("打印BaseService的baseRepository:【"+baseRepository+"】");
    }
}
</pre><p>新建 User.java 泛型实例</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.generic.di;
public class User {
}
</pre><p>新建 UserRepository.java子类, 泛型使用 User</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.generic.di;
import org.springframework.stereotype.Repository;
@Repository  // 将具体实现类交给 IOC 容器 管理
public class UserRepository extends BaseRepository&lt;User&gt; {
}
</pre><p>新建 UserService.java子类, 泛型使用 User</p>
<pre class='brush:java'>package com.yafey.spring.helloworld.generic.di;
import org.springframework.stereotype.Service;
@Service // 将具体实现类交给 IOC 容器 管理
public class UserService extends BaseService&lt;User&gt; {
}
</pre><p>新建 Spring IOC 配置文件</p>
<pre class='brush:xml'>&lt;context:component-scan base-package="com.yafey.spring.helloworld.generic.di"&gt;&lt;/context:component-scan&gt;
</pre><p>新建 TestGenericDI.java 测试类 (其中的main方法)</p>
<pre class='brush:java'>public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext(
            "beans-generic-di.xml");
    UserService userService = (UserService) ctx.getBean("userService");
    userService.add(); // 如果打印的是 UserRepository子类的实例 , 说明 泛型依赖注入 正常(成功).
}
// 输出结果: 泛型依赖注入 成功.
//add...
//打印BaseService的baseRepository:【com.yafey.spring.helloworld.generic.di.UserRepository@617e0655】
</pre></blockquote>
<h2><span id="2.17.many-to-one-config">2.17, 整合多个配置文件</span></h2>
<ul>
<li>Spring 允许通过 <code>&lt;import&gt;</code> 将多个配置文件引入到一个文件中，进行配置文件的集成。这样在启动 Spring 容器时，仅需要指定这个合并好的配置文件就可以。</li>
<li><code>&lt;import&gt;</code>元素的 <strong><code>resource 属性</code></strong>支持 Spring 的标准的路径资源</li>
</ul>
<p><img src="/blog_images/program/spring4.0/2.17.many-to-one-config.png" alt="整合多个配置文件" title="S整合多个配置文件" /></p>
<blockquote><p>示例</p>
<pre class='brush:xml'>&lt;import resource="classpath:beans-spel.xml"/&gt;
</pre></blockquote>
</div>
  <footer>
    <p class="meta">
<span class="byline author vcard">作者 <span class="fn"><a href='https://github.com/yafey'>YaFey</a></span></span>      


<time datetime="2015-02-07T00:06:00+08:00" pubdate>2015年02月07日 00:06:00</time>

<span class="categories">属于 <a class="category" href="/category/tech/java/">Java</a>, <a class="category" href="/category/tech/java/framework/">Java框架</a>, <a class="category" href="/category/tech/java/framework/spring/">Java框架-Spring</a>
 分类</span>


<span class="categories">被贴了 <a class="tag" href="/tag/spring/">Spring</a>, <a class="tag" href="/tag/shang-gui-gu/">尚硅谷</a>
 标签</span>
    </p>
<div class="sharing">
  </div>
<p>
  <h2>相关文章</h2>
  <ul id="related-posts-list">
      <li class="post">
        <a href="/article/2015/02/spring4.0-notes-shangguigu-aop/">Spring4.0学习笔记@尚硅谷 之 AOP部分 (2/n)</a>
        <div class="source right"><time datetime="2015-02-25T00:39:00">2015-02-25</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/02/spring4.0-notes-shangguigu-jdbc-transaction/">Spring4.0学习笔记@尚硅谷 之 JDBC部分(含事务管理) (3/n)</a>
        <div class="source right"><time datetime="2015-02-28T01:16:00">2015-02-28</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/spring-feature-group/">Spring4.0学习笔记--特性部分(1/n)</a>
        <div class="source right"><time datetime="2015-03-11T10:49:00">2015-03-11</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/struts2-notes-shangguigu/">Struts2学习笔记@尚硅谷</a>
        <div class="source right"><time datetime="2015-03-05T22:58:00">2015-03-05</time></div>
      </li>
      <li class="post">
        <a href="/article/2015/03/javaweb-servlet-notes-shangguigu/">JavaWeb学习笔记@尚硅谷---JavaWeb-Servlet(1/n)</a>
        <div class="source right"><time datetime="2015-03-07T13:54:00">2015-03-07</time></div>
      </li>
  </ul>
</p>    <p class="meta">
        <a class="basic-alignment left" href="/article/2015/01/the-way-to-cto-in-java/" title="上一篇: 从程序员到CTO的Java技术路线图">&laquo; 从程序员到CTO的Java技术路线图</a>
        <a class="basic-alignment right" href="/article/2015/02/browser-to-editor/" title="下一篇: (转)奇技淫巧之浏览器秒秒钟变编辑器">(转)奇技淫巧之浏览器秒秒钟变编辑器 &raquo;</a>
    </p>
  </footer>
</article>
</div>
    </div>
  </div>
  <footer role="contentinfo"><p>
  版权所有 &copy; 2015 - <a href='https://github.com/yafey'>YaFey</a> -
  <span class="credit">Powered by <a href="http://www.opoopress.com/">OpooPress</a></span>
</p></footer>
<script type="text/javascript" src="/javascripts/opoopress.min.js"></script>
<script language="JavaScript">
<!--
    window.OpooPress = new OpooPressApp({siteUrl:'http://yoursite.com',rootUrl:'',pageUrl:'/article/2015/02/spring4.0-notes-shangguigu-IOC/',title:'Spring4.0学习笔记@尚硅谷 之 IOC部分 (1/n)',refreshRelativeTimes:true,verbose:true},{});
    OpooPress.init();

//-->
</script>
<!-- START: Syntax Highlighter ComPress -->
<script type="text/javascript" src="/plugins/syntax-highlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="/plugins/syntax-highlighter/scripts/shAutoloader.js"></script>
<script type="text/javascript">
    SyntaxHighlighter.autoloader(
        'applescript			/plugins/syntax-highlighter/scripts/shBrushAppleScript.js',
        'actionscript3 as3		/plugins/syntax-highlighter/scripts/shBrushAS3.js',
        'bash shell				/plugins/syntax-highlighter/scripts/shBrushBash.js',
        'coldfusion cf			/plugins/syntax-highlighter/scripts/shBrushColdFusion.js',
        'cpp c					/plugins/syntax-highlighter/scripts/shBrushCpp.js',
        'c# c-sharp csharp		/plugins/syntax-highlighter/scripts/shBrushCSharp.js',
        'css					/plugins/syntax-highlighter/scripts/shBrushCss.js',
        'delphi pascal pas		/plugins/syntax-highlighter/scripts/shBrushDelphi.js',
        'diff patch			    /plugins/syntax-highlighter/scripts/shBrushDiff.js',
        'erl erlang				/plugins/syntax-highlighter/scripts/shBrushErlang.js',
        'groovy					/plugins/syntax-highlighter/scripts/shBrushGroovy.js',
        'java					/plugins/syntax-highlighter/scripts/shBrushJava.js',
        'jfx javafx				/plugins/syntax-highlighter/scripts/shBrushJavaFX.js',
        'js jscript javascript	/plugins/syntax-highlighter/scripts/shBrushJScript.js',
        'perl pl				/plugins/syntax-highlighter/scripts/shBrushPerl.js',
        'php					/plugins/syntax-highlighter/scripts/shBrushPhp.js',
        'text plain				/plugins/syntax-highlighter/scripts/shBrushPlain.js',
        'powershell ps          /plugins/syntax-highlighter/scripts/shBrushPowerShell.js',
        'py python				/plugins/syntax-highlighter/scripts/shBrushPython.js',
        'ruby rails ror rb		/plugins/syntax-highlighter/scripts/shBrushRuby.js',
        'sass scss              /plugins/syntax-highlighter/scripts/shBrushSass.js',
        'scala					/plugins/syntax-highlighter/scripts/shBrushScala.js',
        'sql					/plugins/syntax-highlighter/scripts/shBrushSql.js',
        'vb vbnet				/plugins/syntax-highlighter/scripts/shBrushVb.js',
        'xml xhtml xslt html	/plugins/syntax-highlighter/scripts/shBrushXml.js'
    );
    SyntaxHighlighter.defaults['auto-links'] = false;                 
    SyntaxHighlighter.defaults['toolbar'] = false;     
    SyntaxHighlighter.defaults['tab-size'] = 4;
    SyntaxHighlighter.all();
</script>
<!-- END: Syntax Highlighter ComPress -->
</body>
</html>

